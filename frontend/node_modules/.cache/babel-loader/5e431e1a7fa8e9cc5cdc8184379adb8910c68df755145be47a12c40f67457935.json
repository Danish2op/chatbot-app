{"ast":null,"code":"var C = Object.defineProperty;\nvar $ = (t, e, r) => e in t ? C(t, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: r\n}) : t[e] = r;\nvar f = (t, e, r) => $(t, typeof e != \"symbol\" ? e + \"\" : e, r);\nimport M from \"fetch-ponyfill\";\nimport w from \"form-data\";\nimport { createMachine as H, assign as c, spawn as N, send as P, actions as j } from \"xstate\";\nlet k = globalThis.fetch;\nconst E = async (t, e, {\n  accessToken: r,\n  name: s,\n  fileId: a,\n  bucketId: i,\n  adminSecret: o,\n  onUploadProgress: d,\n  headers: l = {}\n} = {}) => {\n  var L;\n  const h = {\n    ...l\n  };\n  i && e.append(\"bucket-id\", i), o && (h[\"x-hasura-admin-secret\"] = o), r && (h.Authorization = `Bearer ${r}`);\n  const T = `${t}/files`;\n  if (typeof XMLHttpRequest == \"undefined\") try {\n    e instanceof w && (k = M().fetch);\n    const u = await k(T, {\n        method: \"POST\",\n        headers: h,\n        body: e\n        // * https://github.com/form-data/form-data/issues/513\n      }),\n      n = await u.json();\n    return u.ok ? {\n      fileMetadata: n,\n      error: null\n    } : {\n      error: {\n        status: u.status,\n        message: ((L = n == null ? void 0 : n.error) == null ? void 0 : L.message) || u.statusText,\n        // * errors from hasura-storage are not codified\n        error: u.statusText\n      },\n      fileMetadata: null\n    };\n  } catch (u) {\n    return {\n      error: {\n        status: 0,\n        message: u.message,\n        error: u.message\n      },\n      fileMetadata: null\n    };\n  }\n  return new Promise(u => {\n    let n = new XMLHttpRequest();\n    n.responseType = \"json\", n.onload = () => {\n      var p, g, S, F, R, _, x, I;\n      if (n.status < 200 || n.status >= 300) {\n        const b = {\n          error: (R = (F = (g = (p = n.response) == null ? void 0 : p.error) == null ? void 0 : g.message) != null ? F : (S = n.response) == null ? void 0 : S.error) != null ? R : n.response,\n          message: (I = (x = (_ = n.response) == null ? void 0 : _.error) == null ? void 0 : x.message) != null ? I : n.response,\n          status: n.status\n        };\n        return u({\n          fileMetadata: null,\n          error: b\n        });\n      }\n      return u({\n        fileMetadata: n.response,\n        error: null\n      });\n    }, n.onerror = () => {\n      const p = {\n        error: n.statusText,\n        message: n.statusText,\n        status: n.status\n      };\n      return u({\n        fileMetadata: null,\n        error: p\n      });\n    }, d && n.upload.addEventListener(\"progress\", d, !1), n.open(\"POST\", T, !0), Object.entries(h).forEach(([p, g]) => {\n      n.setRequestHeader(p, g);\n    }), n.send(e);\n  });\n};\nfunction D(t, e) {\n  if (!e || Object.keys(e).length === 0) return t;\n  const r = new URL(t),\n    s = Object.entries(e).reduce((a, [i, o]) => ({\n      ...a,\n      [i.charAt(0)]: o\n    }), {});\n  return Object.entries(s).forEach(([a, i]) => {\n    i && r.searchParams.set(a, i);\n  }), r.toString();\n}\nlet m;\ntypeof m == \"undefined\" && (m = M().fetch);\nclass z {\n  constructor({\n    url: e\n  }) {\n    f(this, \"url\");\n    f(this, \"accessToken\");\n    f(this, \"adminSecret\");\n    f(this, \"headers\", {});\n    this.url = e;\n  }\n  async uploadFormData({\n    formData: e,\n    bucketId: r,\n    headers: s\n  }) {\n    const {\n      error: a,\n      fileMetadata: i\n    } = await E(this.url, e, {\n      bucketId: r,\n      headers: {\n        ...this.headers,\n        // global nhost storage client headers to be sent with all `uploadFormData` calls\n        ...s\n        // extra headers to be sent with a specific call\n      },\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret\n    });\n    return a ? {\n      fileMetadata: null,\n      error: a\n    } : i && !(\"processedFiles\" in i) ? {\n      fileMetadata: {\n        processedFiles: [i]\n      },\n      error: null\n    } : {\n      fileMetadata: i,\n      error: null\n    };\n  }\n  async uploadFile({\n    file: e,\n    bucketId: r,\n    id: s,\n    name: a,\n    headers: i\n  }) {\n    const o = typeof window == \"undefined\" ? new w() : new FormData();\n    o.append(\"file[]\", e), o.append(\"metadata[]\", JSON.stringify({\n      id: s,\n      name: a\n    }));\n    const {\n      error: d,\n      fileMetadata: l\n    } = await E(this.url, o, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId: r,\n      fileId: s,\n      name: a,\n      headers: {\n        ...this.headers,\n        // global nhost storage client headers to be sent with all `uploadFile` calls\n        ...i\n        // extra headers to be sent with a specific call\n      }\n    });\n    return d ? {\n      fileMetadata: null,\n      error: d\n    } : l && \"processedFiles\" in l ? {\n      fileMetadata: l.processedFiles[0],\n      error: null\n    } : {\n      fileMetadata: l,\n      error: null\n    };\n  }\n  async downloadFile(e) {\n    try {\n      const {\n          fileId: r,\n          headers: s,\n          ...a\n        } = e,\n        i = D(`${this.url}/files/${r}`, a),\n        o = await m(i, {\n          method: \"GET\",\n          headers: {\n            ...this.generateAuthHeaders(),\n            ...this.headers,\n            // global nhost storage client headers to be sent with all `downloadFile` calls\n            ...s\n            // extra headers to be sent with a specific call\n          }\n        });\n      if (!o.ok) throw new Error(await o.text());\n      return {\n        file: await o.blob(),\n        error: null\n      };\n    } catch (r) {\n      return {\n        file: null,\n        error: r\n      };\n    }\n  }\n  async getPresignedUrl(e) {\n    try {\n      const {\n          fileId: r,\n          headers: s\n        } = e,\n        a = await m(`${this.url}/files/${r}/presignedurl`, {\n          method: \"GET\",\n          headers: {\n            ...this.generateAuthHeaders(),\n            ...this.headers,\n            // global nhost storage client headers to be sent with all `getPresignedUrl` calls\n            ...s\n            // extra headers to be sent with a specific call\n          }\n        });\n      if (!a.ok) throw new Error(await a.text());\n      return {\n        presignedUrl: await a.json(),\n        error: null\n      };\n    } catch (r) {\n      return {\n        presignedUrl: null,\n        error: r\n      };\n    }\n  }\n  async delete(e) {\n    try {\n      const {\n          fileId: r,\n          headers: s\n        } = e,\n        a = await m(`${this.url}/files/${r}`, {\n          method: \"DELETE\",\n          headers: {\n            ...this.generateAuthHeaders(),\n            ...this.headers,\n            // global nhost storage client headers to be sent with all `delete` calls\n            ...s\n            // extra headers to be sent with a specific call\n          }\n        });\n      if (!a.ok) throw new Error(await a.text());\n      return {\n        error: null\n      };\n    } catch (r) {\n      return {\n        error: r\n      };\n    }\n  }\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(e) {\n    return this.accessToken = e, this;\n  }\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(e) {\n    return this.adminSecret = e, this;\n  }\n  /**\n   * Get global headers sent with all requests.\n   *\n   * @returns Record<string, string>\n   */\n  getHeaders() {\n    return this.headers;\n  }\n  /**\n   * Set global headers to be sent with all requests.\n   *\n   * @param headers a key value pair headers object\n   * @returns Hasura Storage API instance\n   */\n  setHeaders(e) {\n    return e ? (this.headers = {\n      ...this.headers,\n      ...e\n    }, this) : this;\n  }\n  /**\n   * Remove global headers sent with all requests, except for the role header to preserve\n   * the role set by 'setRole' method.\n   *\n   * @returns {HasuraStorageApi} - Hasura Storage API instance.\n   */\n  unsetHeaders() {\n    const e = this.headers[\"x-hasura-role\"];\n    return this.headers = e ? {\n      \"x-hasura-role\": e\n    } : {}, this;\n  }\n  generateAuthHeaders() {\n    if (!(!this.adminSecret && !this.accessToken)) return this.adminSecret ? {\n      \"x-hasura-admin-secret\": this.adminSecret\n    } : {\n      Authorization: `Bearer ${this.accessToken}`\n    };\n  }\n}\nclass W {\n  constructor({\n    url: e,\n    adminSecret: r\n  }) {\n    f(this, \"url\");\n    f(this, \"api\");\n    this.url = e, this.api = new z({\n      url: e\n    }), this.setAdminSecret(r);\n  }\n  async upload(e) {\n    return \"file\" in e ? this.api.uploadFile(e) : this.api.uploadFormData(e);\n  }\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(e) {\n    const {\n      fileId: r,\n      ...s\n    } = e;\n    return D(`${this.url}/files/${r}`, s);\n  }\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(e) {\n    const {\n        fileId: r,\n        headers: s,\n        ...a\n      } = e,\n      {\n        presignedUrl: i,\n        error: o\n      } = await this.api.getPresignedUrl(e);\n    if (o) return {\n      presignedUrl: null,\n      error: o\n    };\n    if (!i) return {\n      presignedUrl: null,\n      error: new Error(\"Invalid file id\")\n    };\n    const d = D(i.url, a);\n    return {\n      presignedUrl: {\n        ...i,\n        url: d\n      },\n      error: null\n    };\n  }\n  /**\n   * Use `nhost.storage.download` to download a file. To download a file the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { file, error} = await nhost.storage.download({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/download\n   */\n  async download(e) {\n    const {\n      file: r,\n      error: s\n    } = await this.api.downloadFile(e);\n    return s ? {\n      file: null,\n      error: s\n    } : r ? {\n      file: r,\n      error: null\n    } : {\n      file: null,\n      error: new Error(\"File does not exist\")\n    };\n  }\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(e) {\n    const {\n      error: r\n    } = await this.api.delete(e);\n    return r ? {\n      error: r\n    } : {\n      error: null\n    };\n  }\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(e) {\n    return this.api.setAccessToken(e), this;\n  }\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(e) {\n    return this.api.setAdminSecret(e), this;\n  }\n  /**\n   * Use `nhost.storage.getHeaders` to get global headers sent with all storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.getHeaders()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-headers\n   */\n  getHeaders() {\n    return this.api.getHeaders();\n  }\n  /**\n   * Use `nhost.storage.setHeaders` to set global headers to be sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setHeaders({\n   *  'x-hasura-role': 'admin'\n   * })\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-headers\n   */\n  setHeaders(e) {\n    return this.api.setHeaders(e), this;\n  }\n  /**\n   * Use `nhost.storage.unsetHeaders` to remove the global headers sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.unsetHeaders()\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/unset-headers\n   */\n  unsetHeaders() {\n    return this.api.unsetHeaders(), this;\n  }\n}\nlet O;\ntypeof O == \"undefined\" && (O = w);\nconst U = {\n    progress: null,\n    loaded: 0,\n    error: null,\n    bucketId: void 0,\n    file: void 0,\n    id: void 0\n  },\n  G = () => H({\n    predictableActionArguments: !0,\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    context: {\n      ...U\n    },\n    initial: \"idle\",\n    on: {\n      DESTROY: {\n        actions: \"sendDestroy\",\n        target: \"stopped\"\n      }\n    },\n    states: {\n      idle: {\n        on: {\n          ADD: {\n            actions: \"addFile\"\n          },\n          UPLOAD: {\n            cond: \"hasFile\",\n            target: \"uploading\"\n          }\n        }\n      },\n      uploading: {\n        entry: \"resetProgress\",\n        on: {\n          UPLOAD_PROGRESS: {\n            actions: [\"incrementProgress\", \"sendProgress\"]\n          },\n          UPLOAD_DONE: \"uploaded\",\n          UPLOAD_ERROR: \"error\",\n          CANCEL: \"idle\"\n        },\n        invoke: {\n          src: \"uploadFile\"\n        }\n      },\n      uploaded: {\n        entry: [\"setFileMetadata\", \"sendDone\"],\n        on: {\n          ADD: {\n            actions: \"addFile\",\n            target: \"idle\"\n          },\n          UPLOAD: {\n            actions: \"resetContext\",\n            target: \"uploading\"\n          }\n        }\n      },\n      error: {\n        entry: [\"setError\", \"sendError\"],\n        on: {\n          ADD: {\n            actions: \"addFile\",\n            target: \"idle\"\n          },\n          UPLOAD: {\n            actions: \"resetContext\",\n            target: \"uploading\"\n          }\n        }\n      },\n      stopped: {\n        type: \"final\"\n      }\n    }\n  }, {\n    guards: {\n      hasFile: (t, e) => !!t.file || !!e.file\n    },\n    actions: {\n      incrementProgress: c({\n        loaded: (t, {\n          loaded: e\n        }) => e,\n        progress: (t, {\n          progress: e\n        }) => e\n      }),\n      setFileMetadata: c({\n        id: (t, {\n          id: e\n        }) => e,\n        bucketId: (t, {\n          bucketId: e\n        }) => e,\n        progress: t => 100\n      }),\n      setError: c({\n        error: (t, {\n          error: e\n        }) => e\n      }),\n      sendProgress: () => {},\n      sendError: () => {},\n      sendDestroy: () => {},\n      sendDone: () => {},\n      resetProgress: c({\n        progress: t => null,\n        loaded: t => 0\n      }),\n      resetContext: c(t => U),\n      addFile: c({\n        file: (t, {\n          file: e\n        }) => e,\n        bucketId: (t, {\n          bucketId: e\n        }) => e,\n        id: (t, {\n          id: e\n        }) => e\n      })\n    },\n    services: {\n      uploadFile: (t, e) => r => {\n        const s = e.file || t.file,\n          a = new O();\n        a.append(\"file[]\", s);\n        let i = 0;\n        return E(e.url, a, {\n          fileId: e.id || t.id,\n          bucketId: e.bucketId || t.bucketId,\n          accessToken: e.accessToken,\n          adminSecret: e.adminSecret,\n          name: e.name || s.name,\n          onUploadProgress: o => {\n            const d = o.total ? Math.round(o.loaded * s.size / o.total) : 0,\n              l = d - i;\n            i = d, r({\n              type: \"UPLOAD_PROGRESS\",\n              progress: o.total ? Math.round(d * 100 / o.total) : 0,\n              loaded: d,\n              additions: l\n            });\n          }\n        }).then(({\n          fileMetadata: o,\n          error: d\n        }) => {\n          if (d && r({\n            type: \"UPLOAD_ERROR\",\n            error: d\n          }), o && !(\"processedFiles\" in o)) {\n            const {\n              id: l,\n              bucketId: h\n            } = o;\n            r({\n              type: \"UPLOAD_DONE\",\n              id: l,\n              bucketId: h\n            });\n          }\n          if (o && \"processedFiles\" in o) {\n            const {\n              id: l,\n              bucketId: h\n            } = o.processedFiles[0];\n            r({\n              type: \"UPLOAD_DONE\",\n              id: l,\n              bucketId: h\n            });\n          }\n        }), () => {};\n      }\n    }\n  }),\n  {\n    pure: y,\n    sendParent: A\n  } = j,\n  Y = () => H({\n    id: \"files-list\",\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    context: {\n      progress: null,\n      files: [],\n      loaded: 0,\n      total: 0\n    },\n    initial: \"idle\",\n    on: {\n      UPLOAD: {\n        cond: \"hasFileToDownload\",\n        actions: \"addItem\",\n        target: \"uploading\"\n      },\n      ADD: {\n        actions: \"addItem\"\n      },\n      REMOVE: {\n        actions: \"removeItem\"\n      }\n    },\n    states: {\n      idle: {\n        entry: [\"resetProgress\", \"resetLoaded\", \"resetTotal\"],\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      },\n      uploading: {\n        entry: [\"upload\", \"startProgress\", \"resetLoaded\", \"resetTotal\"],\n        on: {\n          UPLOAD_PROGRESS: {\n            actions: [\"incrementProgress\"]\n          },\n          UPLOAD_DONE: [{\n            cond: \"isAllUploaded\",\n            target: \"uploaded\"\n          }, {\n            cond: \"isAllUploadedOrError\",\n            target: \"error\"\n          }],\n          UPLOAD_ERROR: [{\n            cond: \"isAllUploaded\",\n            target: \"uploaded\"\n          }, {\n            cond: \"isAllUploadedOrError\",\n            target: \"error\"\n          }],\n          CANCEL: {\n            actions: \"cancel\",\n            target: \"idle\"\n          }\n        }\n      },\n      uploaded: {\n        entry: \"setUploaded\",\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      },\n      error: {\n        on: {\n          CLEAR: {\n            actions: \"clearList\",\n            target: \"idle\"\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      hasFileToDownload: (t, e) => t.files.some(r => r.getSnapshot().matches(\"idle\")) || !!e.files,\n      isAllUploaded: t => t.files.every(e => {\n        var r;\n        return (r = e.getSnapshot()) == null ? void 0 : r.matches(\"uploaded\");\n      }),\n      isAllUploadedOrError: t => t.files.every(e => {\n        const r = e.getSnapshot();\n        return (r == null ? void 0 : r.matches(\"error\")) || (r == null ? void 0 : r.matches(\"uploaded\"));\n      })\n    },\n    actions: {\n      incrementProgress: c((t, e) => {\n        const r = t.loaded + e.additions,\n          s = Math.round(r * 100 / t.total);\n        return {\n          ...t,\n          loaded: r,\n          progress: s\n        };\n      }),\n      setUploaded: c({\n        progress: t => 100,\n        loaded: ({\n          files: t\n        }) => t.map(e => e.getSnapshot()).filter(e => e.matches(\"uploaded\")).reduce((e, r) => {\n          var s;\n          return e + ((s = r.context.file) == null ? void 0 : s.size);\n        }, 0)\n      }),\n      resetTotal: c({\n        total: ({\n          files: t\n        }) => t.map(e => e.getSnapshot()).filter(e => !e.matches(\"uploaded\")).reduce((e, r) => {\n          var s;\n          return e + ((s = r.context.file) == null ? void 0 : s.size);\n        }, 0)\n      }),\n      resetLoaded: c({\n        loaded: t => 0\n      }),\n      startProgress: c({\n        progress: t => 0\n      }),\n      resetProgress: c({\n        progress: t => null\n      }),\n      addItem: c((t, {\n        files: e,\n        bucketId: r\n      }) => {\n        const s = e ? Array.isArray(e) ? e : \"item\" in e ? Array.from(e) : [e] : [],\n          a = t.total + s.reduce((o, d) => o + d.size, 0),\n          i = Math.round(t.loaded * 100 / a);\n        return {\n          files: [...t.files, ...s.map(o => N(G().withConfig({\n            actions: {\n              sendProgress: A((d, {\n                additions: l\n              }) => ({\n                type: \"UPLOAD_PROGRESS\",\n                additions: l\n              })),\n              sendDone: A(\"UPLOAD_DONE\"),\n              sendError: A(\"UPLOAD_ERROR\"),\n              sendDestroy: A(\"REMOVE\")\n            }\n          }).withContext({\n            ...U,\n            file: o,\n            bucketId: r\n          }), {\n            sync: !0\n          }))],\n          total: a,\n          loaded: t.loaded,\n          progress: i\n        };\n      }),\n      removeItem: c({\n        files: t => t.files.filter(e => {\n          var s, a;\n          const r = (s = e.getSnapshot()) == null ? void 0 : s.matches(\"stopped\");\n          return r && ((a = e.stop) == null || a.call(e)), !r;\n        })\n      }),\n      clearList: y(t => t.files.map(e => P({\n        type: \"DESTROY\"\n      }, {\n        to: e.id\n      }))),\n      upload: y((t, e) => t.files.map(r => P(e, {\n        to: r.id\n      }))),\n      cancel: y(t => t.files.map(e => P({\n        type: \"CANCEL\"\n      }, {\n        to: e.id\n      })))\n    }\n  }),\n  J = async (t, e) => new Promise(r => {\n    e.send({\n      type: \"UPLOAD\",\n      ...t\n    }), e.subscribe(s => {\n      var a;\n      s.matches(\"error\") ? r({\n        error: s.context.error,\n        isError: !0,\n        isUploaded: !1\n      }) : s.matches(\"uploaded\") && r({\n        error: null,\n        isError: !1,\n        isUploaded: !0,\n        id: s.context.id,\n        bucketId: s.context.id,\n        name: (a = s.context.file) == null ? void 0 : a.name\n      });\n    });\n  }),\n  K = async (t, e) => new Promise(r => {\n    e.send({\n      type: \"UPLOAD\",\n      ...t,\n      files: t.files\n    }), e.onTransition(s => {\n      s.matches(\"error\") ? r({\n        errors: s.context.files.filter(a => {\n          var i;\n          return (i = a.getSnapshot()) == null ? void 0 : i.context.error;\n        }),\n        isError: !0,\n        files: []\n      }) : s.matches(\"uploaded\") && r({\n        errors: [],\n        isError: !1,\n        files: s.context.files\n      });\n    });\n  });\nexport { z as HasuraStorageApi, W as HasuraStorageClient, U as INITIAL_FILE_CONTEXT, D as appendImageTransformationParameters, G as createFileUploadMachine, Y as createMultipleFilesUploadMachine, J as uploadFilePromise, K as uploadMultipleFilesPromise };","map":{"version":3,"names":["k","globalThis","fetch","E","fetchUpload","t","e","accessToken","r","name","s","fileId","a","bucketId","i","adminSecret","o","onUploadProgress","d","headers","l","h","append","Authorization","T","XMLHttpRequest","w","M","u","method","body","n","json","ok","fileMetadata","error","status","message","L","statusText","Promise","responseType","onload","b","R","F","g","p","response","S","I","x","_","onerror","upload","addEventListener","open","Object","entries","forEach","setRequestHeader","send","D","keys","length","URL","reduce","charAt","searchParams","set","toString","m","z","constructor","url","f","uploadFormData","formData","processedFiles","uploadFile","file","id","window","FormData","JSON","stringify","downloadFile","generateAuthHeaders","Error","text","blob","getPresignedUrl","presignedUrl","delete","setAccessToken","setAdminSecret","getHeaders","setHeaders","unsetHeaders","W","api","getPublicUrl","download","O","U","progress","loaded","G","createFileUploadMachine","H","predictableActionArguments","schema","context","events","tsTypes","initial","on","DESTROY","actions","target","states","idle","ADD","UPLOAD","cond","uploading","entry","UPLOAD_PROGRESS","UPLOAD_DONE","UPLOAD_ERROR","CANCEL","invoke","src","uploaded","stopped","type","guards","hasFile","incrementProgress","c","setFileMetadata","setError","sendProgress","sendError","sendDestroy","sendDone","resetProgress","resetContext","addFile","services","total","Math","round","size","additions","then","pure","y","sendParent","A","j","Y","createMultipleFilesUploadMachine","files","REMOVE","CLEAR","hasFileToDownload","some","getSnapshot","matches","isAllUploaded","every","isAllUploadedOrError","setUploaded","map","filter","resetTotal","resetLoaded","startProgress","addItem","Array","isArray","from","N","withConfig","withContext","sync","removeItem","stop","call","clearList","P","to","cancel","J","uploadFilePromise","subscribe","isError","isUploaded","K","uploadMultipleFilesPromise","onTransition","errors"],"sources":["D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\utils\\upload.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\utils\\appendImageTransformationParameters\\appendImageTransformationParameters.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\hasura-storage-api.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\hasura-storage-client.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\machines\\file-upload.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\machines\\multiple-files-upload.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\promises\\file-upload.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-storage-js\\src\\promises\\multiple-files-upload.ts"],"sourcesContent":["import fetchPonyfill from 'fetch-ponyfill'\nimport LegacyFormData from 'form-data'\nimport { StorageErrorPayload, StorageUploadResponse } from './types'\n\nlet fetch = globalThis.fetch\n\n/** Convert any string into ISO-8859-1 */\nexport const toIso88591 = (fileName: string) => {\n  try {\n    btoa(fileName)\n    return fileName\n  } catch {\n    return encodeURIComponent(fileName)\n  }\n}\n\nexport const fetchUpload = async (\n  backendUrl: string,\n  data: FormData | LegacyFormData,\n  {\n    accessToken,\n    name,\n    fileId,\n    bucketId,\n    adminSecret,\n    onUploadProgress,\n    headers: initialHeaders = {}\n  }: {\n    accessToken?: string\n    name?: string\n    fileId?: string\n    bucketId?: string\n    adminSecret?: string\n    onUploadProgress?: (event: { total: number; loaded: number }) => void\n    headers?: Record<string, string>\n  } = {}\n): Promise<StorageUploadResponse> => {\n  const headers: HeadersInit = {\n    ...initialHeaders\n  }\n  if (bucketId) {\n    data.append('bucket-id', bucketId)\n  }\n  if (adminSecret) {\n    headers['x-hasura-admin-secret'] = adminSecret\n  }\n  if (accessToken) {\n    headers['Authorization'] = `Bearer ${accessToken}`\n  }\n\n  const url = `${backendUrl}/files`\n  if (typeof XMLHttpRequest === 'undefined') {\n    // * Non-browser environment: XMLHttpRequest is not available\n    try {\n      if (data instanceof LegacyFormData) {\n        fetch = fetchPonyfill().fetch\n      }\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: data as any // * https://github.com/form-data/form-data/issues/513\n      })\n\n      const responseData = await response.json()\n\n      if (!response.ok) {\n        const error: StorageErrorPayload = {\n          status: response.status,\n          message: responseData?.error?.message || response.statusText,\n          // * errors from hasura-storage are not codified\n          error: response.statusText\n        }\n        return { error, fileMetadata: null }\n      }\n      const fileMetadata = responseData\n      return { fileMetadata, error: null }\n    } catch (e) {\n      const error: StorageErrorPayload = {\n        status: 0,\n        message: (e as Error).message,\n        error: (e as Error).message\n      }\n      return { error, fileMetadata: null }\n    }\n  }\n\n  // * Browser environment: XMLHttpRequest is available\n  return new Promise((resolve) => {\n    let xhr = new XMLHttpRequest()\n    xhr.responseType = 'json'\n\n    xhr.onload = () => {\n      if (xhr.status < 200 || xhr.status >= 300) {\n        const error: StorageErrorPayload = {\n          error: xhr.response?.error?.message ?? xhr.response?.error ?? xhr.response,\n          message: xhr.response?.error?.message ?? xhr.response,\n          status: xhr.status\n        }\n        return resolve({\n          fileMetadata: null,\n          error\n        })\n      }\n      return resolve({ fileMetadata: xhr.response, error: null })\n    }\n\n    xhr.onerror = () => {\n      // only triggers if the request couldn't be made at all e.g. network error\n      const error: StorageErrorPayload = {\n        error: xhr.statusText,\n        message: xhr.statusText,\n        status: xhr.status\n      }\n      return resolve({\n        fileMetadata: null,\n        error\n      })\n    }\n\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', onUploadProgress, false)\n    }\n\n    xhr.open('POST', url, true)\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    xhr.send(data as any) // * https://github.com/form-data/form-data/issues/513\n  })\n}\n","import { StorageImageTransformationParams } from '../types'\n\n/**\n * Appends image transformation parameters to the URL. If the URL already\n * contains query parameters, the transformation parameters are appended to\n * the existing query parameters.\n *\n * @internal\n * @param url - The URL to append the transformation parameters to.\n * @param params - The image transformation parameters.\n * @returns The URL with the transformation parameters appended.\n */\nexport default function appendImageTransformationParameters(\n  url: string,\n  params?: StorageImageTransformationParams\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return url\n  }\n\n  const urlObject = new URL(url)\n\n  // create an object with the transformation parameters by using the first\n  // character of the parameter name as the key\n  const imageTransformationParams = Object.entries(params).reduce(\n    (accumulator, [key, value]) => ({ ...accumulator, [key.charAt(0)]: value }),\n    {} as Record<string, any>\n  )\n\n  // set the query parameters in the URL object\n  Object.entries(imageTransformationParams).forEach(([key, value]) => {\n    if (!value) {\n      return\n    }\n\n    urlObject.searchParams.set(key, value)\n  })\n\n  return urlObject.toString()\n}\n","import fetchPonyfill from 'fetch-ponyfill'\n\nimport LegacyFormData from 'form-data'\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  StorageDownloadFileParams,\n  StorageDownloadFileResponse,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse\n} from './utils/types'\nimport { fetchUpload } from './utils/upload'\nimport { appendImageTransformationParameters } from './utils'\n\nlet fetch: any\n\nif (typeof fetch === 'undefined') {\n  fetch = fetchPonyfill().fetch\n}\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private accessToken?: string\n  private adminSecret?: string\n  private headers: Record<string, string> = {}\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n  }\n\n  async uploadFormData({\n    formData,\n    bucketId,\n    headers: extraHeaders\n  }: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse> {\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      bucketId,\n      headers: {\n        ...this.headers, // global nhost storage client headers to be sent with all `uploadFormData` calls\n        ...extraHeaders // extra headers to be sent with a specific call\n      },\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && !('processedFiles' in fileMetadata)) {\n      return {\n        fileMetadata: {\n          processedFiles: [fileMetadata]\n        },\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async uploadFile({\n    file,\n    bucketId,\n    id,\n    name,\n    headers: extraHeaders\n  }: StorageUploadFileParams): Promise<StorageUploadFileResponse> {\n    const formData = typeof window === 'undefined' ? new LegacyFormData() : new FormData()\n\n    formData.append('file[]', file)\n    formData.append('metadata[]', JSON.stringify({ id, name }))\n\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId,\n      fileId: id,\n      name,\n      headers: {\n        ...this.headers, // global nhost storage client headers to be sent with all `uploadFile` calls\n        ...extraHeaders // extra headers to be sent with a specific call\n      }\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && 'processedFiles' in fileMetadata) {\n      return {\n        fileMetadata: fileMetadata.processedFiles[0],\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async downloadFile(params: StorageDownloadFileParams): Promise<StorageDownloadFileResponse> {\n    try {\n      const { fileId, headers: extraHeaders, ...imageTransformationParams } = params\n\n      const urlWithParams = appendImageTransformationParameters(\n        `${this.url}/files/${fileId}`,\n        imageTransformationParams\n      )\n\n      const response = await fetch(urlWithParams, {\n        method: 'GET',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `downloadFile` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n\n      const file = await response.blob()\n\n      return { file, error: null }\n    } catch (error) {\n      return { file: null, error: error as Error }\n    }\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId, headers: extraHeaders } = params\n\n      const response = await fetch(`${this.url}/files/${fileId}/presignedurl`, {\n        method: 'GET',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `getPresignedUrl` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      const presignedUrl = await response.json()\n      return { presignedUrl, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId, headers: extraHeaders } = params\n      const response = await fetch(`${this.url}/files/${fileId}`, {\n        method: 'DELETE',\n        headers: {\n          ...this.generateAuthHeaders(),\n          ...this.headers, // global nhost storage client headers to be sent with all `delete` calls\n          ...extraHeaders // extra headers to be sent with a specific call\n        }\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  /**\n   * Get global headers sent with all requests.\n   *\n   * @returns Record<string, string>\n   */\n  getHeaders(): Record<string, string> {\n    return this.headers\n  }\n\n  /**\n   * Set global headers to be sent with all requests.\n   *\n   * @param headers a key value pair headers object\n   * @returns Hasura Storage API instance\n   */\n  setHeaders(headers?: Record<string, string>): HasuraStorageApi {\n    if (!headers) {\n      return this\n    }\n\n    this.headers = {\n      ...this.headers,\n      ...headers\n    }\n\n    return this\n  }\n\n  /**\n   * Remove global headers sent with all requests, except for the role header to preserve\n   * the role set by 'setRole' method.\n   *\n   * @returns {HasuraStorageApi} - Hasura Storage API instance.\n   */\n  unsetHeaders(): HasuraStorageApi {\n    const userRole = this.headers['x-hasura-role']\n\n    // preserve the user role header to avoid invalidating preceding 'setRole' call.\n    this.headers = userRole ? { 'x-hasura-role': userRole } : {}\n\n    return this\n  }\n\n  private generateAuthHeaders(): HeadersInit | undefined {\n    if (!this.adminSecret && !this.accessToken) {\n      return undefined\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n","import { HasuraStorageApi } from './hasura-storage-api'\nimport {\n  appendImageTransformationParameters,\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse,\n  StorageUploadParams,\n  StorageUploadResponse,\n  StorageDownloadFileParams,\n  StorageDownloadFileResponse\n} from './utils'\n\nexport interface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadFileResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    if ('file' in params) {\n      return this.api.uploadFile(params)\n    }\n\n    return this.api.uploadFormData(params)\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId, ...imageTransformationParams } = params\n    return appendImageTransformationParameters(\n      `${this.url}/files/${fileId}`,\n      imageTransformationParams\n    )\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { fileId, headers, ...imageTransformationParams } = params\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    const urlWithTransformationParams = appendImageTransformationParameters(\n      presignedUrl.url,\n      imageTransformationParams\n    )\n\n    return {\n      presignedUrl: {\n        ...presignedUrl,\n        url: urlWithTransformationParams\n      },\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.download` to download a file. To download a file the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { file, error} = await nhost.storage.download({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/download\n   */\n  async download(params: StorageDownloadFileParams): Promise<StorageDownloadFileResponse> {\n    const { file, error } = await this.api.downloadFile(params)\n\n    if (error) {\n      return { file: null, error }\n    }\n\n    if (!file) {\n      return { file: null, error: new Error('File does not exist') }\n    }\n\n    return {\n      file,\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.getHeaders` to get global headers sent with all storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.getHeaders()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-headers\n   */\n  getHeaders(): Record<string, string> {\n    return this.api.getHeaders()\n  }\n\n  /**\n   * Use `nhost.storage.setHeaders` to set global headers to be sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setHeaders({\n   *  'x-hasura-role': 'admin'\n   * })\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-headers\n   */\n  setHeaders(headers?: Record<string, string>): HasuraStorageClient {\n    this.api.setHeaders(headers)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.unsetHeaders` to remove the global headers sent for all subsequent storage requests.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.unsetHeaders()\n   * ```\n   *\n   * @param headers key value headers object\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/unset-headers\n   */\n  unsetHeaders(): HasuraStorageClient {\n    this.api.unsetHeaders()\n    return this\n  }\n}\n","import { assign, createMachine } from 'xstate'\nimport { FileUploadConfig, StorageErrorPayload } from '../utils'\nimport { fetchUpload } from '../utils/upload'\n\nimport FallbackFormData from 'form-data'\n\nlet FormData: any\n\nif (typeof FormData === 'undefined') {\n  FormData = FallbackFormData\n}\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: StorageErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEventPayload = {}\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | ({\n      type: 'UPLOAD'\n      file?: File\n      id?: string\n      name?: string\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: StorageErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = {\n  progress: null,\n  loaded: 0,\n  error: null,\n  bucketId: undefined,\n  file: undefined,\n  id: undefined\n}\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      predictableActionArguments: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: {\n          entry: ['setFileMetadata', 'sendDone'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        error: {\n          entry: ['setError', 'sendError'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        resetContext: assign((_) => INITIAL_FILE_CONTEXT),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const file = (event.file || context.file)!\n          const data = new FormData()\n          data.append('file[]', file)\n\n          let currentLoaded = 0\n\n          fetchUpload(event.url, data, {\n            fileId: event.id || context.id,\n            bucketId: event.bucketId || context.bucketId,\n            accessToken: event.accessToken,\n            adminSecret: event.adminSecret,\n            name: event.name || file.name,\n            onUploadProgress: (event) => {\n              const loaded = event.total ? Math.round((event.loaded * file.size!) / event.total) : 0\n              const additions = loaded - currentLoaded\n              currentLoaded = loaded\n              callback({\n                type: 'UPLOAD_PROGRESS',\n                progress: event.total ? Math.round((loaded * 100) / event.total) : 0,\n                loaded,\n                additions\n              })\n            }\n          }).then(({ fileMetadata, error }) => {\n            if (error) {\n              callback({ type: 'UPLOAD_ERROR', error })\n            }\n            if (fileMetadata && !('processedFiles' in fileMetadata)) {\n              const { id, bucketId } = fileMetadata\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n\n            if (fileMetadata && 'processedFiles' in fileMetadata) {\n              // TODO: Add support for multiple files\n              const { id, bucketId } = fileMetadata.processedFiles[0]\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n          })\n\n          return () => {}\n        }\n      }\n    }\n  )\n","import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { FileUploadConfig } from '../utils'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | ({\n      type: 'UPLOAD'\n      files?: AnyFileList\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      predictableActionArguments: true,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'item' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { FileUploadConfig, StorageActionErrorState, StorageUploadFileParams } from '../utils'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends StorageActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  params: FileUploadConfig & Partial<StorageUploadFileParams>,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { FileUploadConfig } from '../utils'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  params: FileUploadConfig & UploadMultipleFilesActionParams,\n  service: InterpreterFrom<MultipleFilesUploadMachine>\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      ...params,\n      files: params.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}