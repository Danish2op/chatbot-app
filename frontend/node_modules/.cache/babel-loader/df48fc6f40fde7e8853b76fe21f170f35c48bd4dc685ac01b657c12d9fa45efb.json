{"ast":null,"code":"import { jwtDecode as Te } from \"jwt-decode\";\nimport { createMachine as N, send as w, assign as g, interpret as C } from \"xstate\";\nimport H from \"js-cookie\";\nimport pe from \"fetch-ponyfill\";\nconst x = \"nhostRefreshToken\",\n  U = \"nhostRefreshTokenId\",\n  O = \"nhostRefreshTokenExpiresAt\",\n  we = 3,\n  Q = 60,\n  X = 5,\n  ie = 0,\n  oe = 1,\n  v = 10,\n  D = 20;\nclass b extends Error {\n  constructor(e) {\n    super(e.message), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), e instanceof Error ? (this.name = e.name, this.error = {\n      error: e.name,\n      status: oe,\n      message: e.message\n    }) : (this.name = e.error, this.error = e);\n  }\n}\nconst R = {\n    status: v,\n    error: \"invalid-email\",\n    message: \"Email is incorrectly formatted\"\n  },\n  ke = {\n    status: v,\n    error: \"invalid-mfa-type\",\n    message: \"MFA type is invalid\"\n  },\n  ye = {\n    status: v,\n    error: \"invalid-mfa-code\",\n    message: \"MFA code is invalid\"\n  },\n  Y = {\n    status: v,\n    error: \"invalid-password\",\n    message: \"Password is incorrectly formatted\"\n  },\n  Z = {\n    status: v,\n    error: \"invalid-phone-number\",\n    message: \"Phone number is incorrectly formatted\"\n  },\n  Ie = {\n    status: v,\n    error: \"invalid-mfa-ticket\",\n    message: \"MFA ticket is invalid\"\n  },\n  Se = {\n    status: v,\n    error: \"no-mfa-ticket\",\n    message: \"No MFA ticket has been provided\"\n  },\n  Ae = {\n    status: v,\n    error: \"no-refresh-token\",\n    message: \"No refresh token has been provided\"\n  },\n  Re = {\n    status: D,\n    error: \"refresher-already-running\",\n    message: \"The token refresher is already running. You must wait until is has finished before submitting a new token.\"\n  },\n  k = {\n    status: D,\n    error: \"already-signed-in\",\n    message: \"User is already signed in\"\n  },\n  _e = {\n    status: D,\n    error: \"unauthenticated-user\",\n    message: \"User is not authenticated\"\n  },\n  wr = {\n    status: D,\n    error: \"user-not-anonymous\",\n    message: \"User is not anonymous\"\n  },\n  ve = {\n    status: D,\n    error: \"unverified-user\",\n    message: \"Email needs verification\"\n  },\n  Pe = {\n    status: v,\n    error: \"invalid-refresh-token\",\n    message: \"Invalid or expired refresh token\"\n  },\n  Oe = {\n    status: oe,\n    error: \"invalid-sign-in-method\",\n    message: \"Invalid sign-in method\"\n  },\n  $ = {\n    user: null,\n    mfa: null,\n    accessToken: {\n      value: null,\n      expiresAt: null,\n      expiresInSeconds: 15\n    },\n    refreshTimer: {\n      startedAt: null,\n      attempts: 0,\n      lastAttempt: null\n    },\n    refreshToken: {\n      value: null\n    },\n    importTokenAttempts: 0,\n    errors: {}\n  };\nfunction be(s) {\n  return new TextEncoder().encode(s);\n}\nfunction P(s) {\n  const e = new Uint8Array(s);\n  let r = \"\";\n  for (const t of e) r += String.fromCharCode(t);\n  return btoa(r).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction q(s) {\n  const e = s.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n    r = (4 - e.length % 4) % 4,\n    n = e.padEnd(e.length + r, \"=\"),\n    t = atob(n),\n    i = new ArrayBuffer(t.length),\n    u = new Uint8Array(i);\n  for (let f = 0; f < t.length; f++) u[f] = t.charCodeAt(f);\n  return i;\n}\nfunction ae() {\n  return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == \"function\";\n}\nfunction ce(s) {\n  const {\n    id: e\n  } = s;\n  return {\n    ...s,\n    id: q(e),\n    transports: s.transports\n  };\n}\nfunction ue(s) {\n  return s === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(s);\n}\nclass p extends Error {\n  constructor({\n    message: e,\n    code: r,\n    cause: n,\n    name: t\n  }) {\n    super(e, {\n      cause: n\n    }), this.name = t != null ? t : n.name, this.code = r;\n  }\n}\nfunction Ne({\n  error: s,\n  options: e\n}) {\n  var n, t;\n  const {\n    publicKey: r\n  } = e;\n  if (!r) throw Error(\"options was missing required publicKey property\");\n  if (s.name === \"AbortError\") {\n    if (e.signal instanceof AbortSignal) return new p({\n      message: \"Registration ceremony was sent an abort signal\",\n      code: \"ERROR_CEREMONY_ABORTED\",\n      cause: s\n    });\n  } else if (s.name === \"ConstraintError\") {\n    if (((n = r.authenticatorSelection) == null ? void 0 : n.requireResidentKey) === !0) return new p({\n      message: \"Discoverable credentials were required but no available authenticator supported it\",\n      code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n      cause: s\n    });\n    if (((t = r.authenticatorSelection) == null ? void 0 : t.userVerification) === \"required\") return new p({\n      message: \"User verification was required but no available authenticator supported it\",\n      code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n      cause: s\n    });\n  } else {\n    if (s.name === \"InvalidStateError\") return new p({\n      message: \"The authenticator was previously registered\",\n      code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n      cause: s\n    });\n    if (s.name === \"NotAllowedError\") return new p({\n      message: s.message,\n      code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n      cause: s\n    });\n    if (s.name === \"NotSupportedError\") return r.pubKeyCredParams.filter(u => u.type === \"public-key\").length === 0 ? new p({\n      message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n      code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n      cause: s\n    }) : new p({\n      message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n      code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n      cause: s\n    });\n    if (s.name === \"SecurityError\") {\n      const i = window.location.hostname;\n      if (ue(i)) {\n        if (r.rp.id !== i) return new p({\n          message: `The RP ID \"${r.rp.id}\" is invalid for this domain`,\n          code: \"ERROR_INVALID_RP_ID\",\n          cause: s\n        });\n      } else return new p({\n        message: `${window.location.hostname} is an invalid domain`,\n        code: \"ERROR_INVALID_DOMAIN\",\n        cause: s\n      });\n    } else if (s.name === \"TypeError\") {\n      if (r.user.id.byteLength < 1 || r.user.id.byteLength > 64) return new p({\n        message: \"User ID was not between 1 and 64 characters\",\n        code: \"ERROR_INVALID_USER_ID_LENGTH\",\n        cause: s\n      });\n    } else if (s.name === \"UnknownError\") return new p({\n      message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n      code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n      cause: s\n    });\n  }\n  return s;\n}\nclass xe {\n  createNewAbortSignal() {\n    if (this.controller) {\n      const r = new Error(\"Cancelling existing WebAuthn API call for new one\");\n      r.name = \"AbortError\", this.controller.abort(r);\n    }\n    const e = new AbortController();\n    return this.controller = e, e.signal;\n  }\n  cancelCeremony() {\n    if (this.controller) {\n      const e = new Error(\"Manually cancelling existing WebAuthn API call\");\n      e.name = \"AbortError\", this.controller.abort(e), this.controller = void 0;\n    }\n  }\n}\nconst le = new xe(),\n  Ce = [\"cross-platform\", \"platform\"];\nfunction de(s) {\n  if (s && !(Ce.indexOf(s) < 0)) return s;\n}\nasync function fe(s) {\n  var a;\n  if (!ae()) throw new Error(\"WebAuthn is not supported in this browser\");\n  const r = {\n    publicKey: {\n      ...s,\n      challenge: q(s.challenge),\n      user: {\n        ...s.user,\n        id: be(s.user.id)\n      },\n      excludeCredentials: (a = s.excludeCredentials) == null ? void 0 : a.map(ce)\n    }\n  };\n  r.signal = le.createNewAbortSignal();\n  let n;\n  try {\n    n = await navigator.credentials.create(r);\n  } catch (o) {\n    throw Ne({\n      error: o,\n      options: r\n    });\n  }\n  if (!n) throw new Error(\"Registration was not completed\");\n  const {\n    id: t,\n    rawId: i,\n    response: u,\n    type: f\n  } = n;\n  let d;\n  typeof u.getTransports == \"function\" && (d = u.getTransports());\n  let h;\n  if (typeof u.getPublicKeyAlgorithm == \"function\") try {\n    h = u.getPublicKeyAlgorithm();\n  } catch (o) {\n    W(\"getPublicKeyAlgorithm()\", o);\n  }\n  let E;\n  if (typeof u.getPublicKey == \"function\") try {\n    const o = u.getPublicKey();\n    o !== null && (E = P(o));\n  } catch (o) {\n    W(\"getPublicKey()\", o);\n  }\n  let T;\n  if (typeof u.getAuthenticatorData == \"function\") try {\n    T = P(u.getAuthenticatorData());\n  } catch (o) {\n    W(\"getAuthenticatorData()\", o);\n  }\n  return {\n    id: t,\n    rawId: P(i),\n    response: {\n      attestationObject: P(u.attestationObject),\n      clientDataJSON: P(u.clientDataJSON),\n      transports: d,\n      publicKeyAlgorithm: h,\n      publicKey: E,\n      authenticatorData: T\n    },\n    type: f,\n    clientExtensionResults: n.getClientExtensionResults(),\n    authenticatorAttachment: de(n.authenticatorAttachment)\n  };\n}\nfunction W(s, e) {\n  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${s}. You should report this error to them.\n`, e);\n}\nfunction De(s) {\n  return new TextDecoder(\"utf-8\").decode(s);\n}\nfunction Ue() {\n  const s = window.PublicKeyCredential;\n  return s.isConditionalMediationAvailable === void 0 ? new Promise(e => e(!1)) : s.isConditionalMediationAvailable();\n}\nfunction Me({\n  error: s,\n  options: e\n}) {\n  const {\n    publicKey: r\n  } = e;\n  if (!r) throw Error(\"options was missing required publicKey property\");\n  if (s.name === \"AbortError\") {\n    if (e.signal instanceof AbortSignal) return new p({\n      message: \"Authentication ceremony was sent an abort signal\",\n      code: \"ERROR_CEREMONY_ABORTED\",\n      cause: s\n    });\n  } else {\n    if (s.name === \"NotAllowedError\") return new p({\n      message: s.message,\n      code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n      cause: s\n    });\n    if (s.name === \"SecurityError\") {\n      const n = window.location.hostname;\n      if (ue(n)) {\n        if (r.rpId !== n) return new p({\n          message: `The RP ID \"${r.rpId}\" is invalid for this domain`,\n          code: \"ERROR_INVALID_RP_ID\",\n          cause: s\n        });\n      } else return new p({\n        message: `${window.location.hostname} is an invalid domain`,\n        code: \"ERROR_INVALID_DOMAIN\",\n        cause: s\n      });\n    } else if (s.name === \"UnknownError\") return new p({\n      message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n      code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n      cause: s\n    });\n  }\n  return s;\n}\nasync function j(s, e = !1) {\n  var T, a;\n  if (!ae()) throw new Error(\"WebAuthn is not supported in this browser\");\n  let r;\n  ((T = s.allowCredentials) == null ? void 0 : T.length) !== 0 && (r = (a = s.allowCredentials) == null ? void 0 : a.map(ce));\n  const n = {\n      ...s,\n      challenge: q(s.challenge),\n      allowCredentials: r\n    },\n    t = {};\n  if (e) {\n    if (!(await Ue())) throw Error(\"Browser does not support WebAuthn autofill\");\n    if (document.querySelectorAll(\"input[autocomplete$='webauthn']\").length < 1) throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n    t.mediation = \"conditional\", n.allowCredentials = [];\n  }\n  t.publicKey = n, t.signal = le.createNewAbortSignal();\n  let i;\n  try {\n    i = await navigator.credentials.get(t);\n  } catch (o) {\n    throw Me({\n      error: o,\n      options: t\n    });\n  }\n  if (!i) throw new Error(\"Authentication was not completed\");\n  const {\n    id: u,\n    rawId: f,\n    response: d,\n    type: h\n  } = i;\n  let E;\n  return d.userHandle && (E = De(d.userHandle)), {\n    id: u,\n    rawId: P(f),\n    response: {\n      authenticatorData: P(d.authenticatorData),\n      clientDataJSON: P(d.clientDataJSON),\n      signature: P(d.signature),\n      userHandle: E\n    },\n    type: h,\n    clientExtensionResults: i.getClientExtensionResults(),\n    authenticatorAttachment: de(i.authenticatorAttachment)\n  };\n}\nconst G = typeof window != \"undefined\",\n  V = /* @__PURE__ */new Map(),\n  Ke = s => {\n    var e;\n    return G && typeof localStorage != \"undefined\" ? localStorage.getItem(s) : (e = V.get(s)) != null ? e : null;\n  },\n  Ve = (s, e) => {\n    G && typeof localStorage != \"undefined\" ? e ? localStorage.setItem(s, e) : localStorage.removeItem(s) : e ? V.set(s, e) : V.has(s) && V.delete(s);\n  },\n  Le = (s, e) => {\n    if (s === \"localStorage\" || s === \"web\") return Ke;\n    if (s === \"cookie\") return r => {\n      var n;\n      return G && (n = H.get(r)) != null ? n : null;\n    };\n    if (!e) throw Error(`clientStorageType is set to '${s}' but no clientStorage has been given`);\n    if (s === \"react-native\") return r => {\n      var n;\n      return (n = e.getItem) == null ? void 0 : n.call(e, r);\n    };\n    if (s === \"capacitor\") return r => {\n      var n;\n      return (n = e.get) == null ? void 0 : n.call(e, {\n        key: r\n      });\n    };\n    if (s === \"expo-secure-storage\") return r => {\n      var n;\n      return (n = e.getItemAsync) == null ? void 0 : n.call(e, r);\n    };\n    if (s === \"custom\") {\n      if (e.getItem && e.removeItem) return e.getItem;\n      if (e.getItemAsync) return e.getItemAsync;\n      throw Error(`clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`);\n    }\n    throw Error(`Unknown storage type: ${s}`);\n  },\n  Ge = (s, e) => {\n    if (s === \"localStorage\" || s === \"web\") return Ve;\n    if (s === \"cookie\") return (r, n) => {\n      G && (n ? H.set(r, n, {\n        expires: 30,\n        sameSite: \"lax\",\n        httpOnly: !1\n      }) : H.remove(r));\n    };\n    if (!e) throw Error(`clientStorageType is set to '${s}' but no clienStorage has been given`);\n    if (s === \"react-native\") return (r, n) => {\n      var t, i;\n      return n ? (t = e.setItem) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);\n    };\n    if (s === \"capacitor\") return (r, n) => {\n      var t, i;\n      return n ? (t = e.set) == null ? void 0 : t.call(e, {\n        key: r,\n        value: n\n      }) : (i = e.remove) == null ? void 0 : i.call(e, {\n        key: r\n      });\n    };\n    if (s === \"expo-secure-storage\") return async (r, n) => {\n      var t, i;\n      return n ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, n) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, r);\n    };\n    if (s === \"custom\") {\n      if (!e.removeItem) throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing a removeItem property\");\n      if (e.setItem) return (r, n) => {\n        var t, i;\n        return n ? (t = e.setItem) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);\n      };\n      if (e.setItemAsync) return async (r, n) => {\n        var t, i;\n        return n ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);\n      };\n      throw Error(\"clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property\");\n    }\n    throw Error(`Unknown storage type: ${s}`);\n  },\n  M = s => !s || !s.accessToken.value || !s.accessToken.expiresAt || !s.user ? null : {\n    accessToken: s.accessToken.value,\n    accessTokenExpiresIn: (s.accessToken.expiresAt.getTime() - Date.now()) / 1e3,\n    refreshToken: s.refreshToken.value,\n    user: s.user\n  },\n  A = ({\n    accessToken: s,\n    refreshToken: e,\n    isError: r,\n    user: n,\n    error: t\n  }) => r ? {\n    session: null,\n    error: t\n  } : n && s ? {\n    // TODO either return the refresh token or remove it from the session type\n    session: {\n      accessToken: s,\n      accessTokenExpiresIn: 0,\n      refreshToken: e,\n      user: n\n    },\n    error: null\n  } : {\n    session: null,\n    error: null\n  },\n  L = () => typeof window != \"undefined\" && typeof window.location != \"undefined\";\nlet he = globalThis.fetch;\ntypeof EdgeRuntime != \"string\" && (he = pe().fetch);\nconst me = async (s, e, {\n    token: r,\n    body: n,\n    extraHeaders: t\n  } = {}) => {\n    const i = {\n      \"Content-Type\": \"application/json\",\n      Accept: \"*/*\"\n    };\n    r && (i.Authorization = `Bearer ${r}`);\n    const u = {\n        ...i,\n        ...t\n      },\n      f = {\n        method: e,\n        headers: u\n      };\n    n && (f.body = JSON.stringify(n));\n    try {\n      const d = await he(s, f);\n      if (!d.ok) {\n        const h = await d.json();\n        return Promise.reject({\n          error: h\n        });\n      }\n      try {\n        return {\n          data: await d.json(),\n          error: null\n        };\n      } catch {\n        return console.warn(`Unexpected response: can't parse the response of the server at ${s}`), {\n          data: \"OK\",\n          error: null\n        };\n      }\n    } catch {\n      const h = {\n        message: \"Network Error\",\n        status: ie,\n        error: \"network\"\n      };\n      return Promise.reject({\n        error: h\n      });\n    }\n  },\n  I = async (s, e, r, n) => me(s, \"POST\", {\n    token: r,\n    body: e,\n    extraHeaders: n\n  }),\n  $e = (s, e) => me(s, \"GET\", {\n    token: e\n  }),\n  F = (s, e) => {\n    const r = e && Object.entries(e).map(([n, t]) => {\n      const i = Array.isArray(t) ? t.join(\",\") : typeof t == \"object\" ? JSON.stringify(t) : t;\n      return `${n}=${encodeURIComponent(i)}`;\n    }).join(\"&\");\n    return r ? `${s}?${r}` : s;\n  },\n  S = (s, e) => {\n    if (!(e != null && e.redirectTo)) return e;\n    const {\n      redirectTo: r,\n      ...n\n    } = e;\n    if (!s) return r.startsWith(\"/\") ? n : e;\n    const t = new URL(s),\n      i = Object.fromEntries(new URLSearchParams(t.search)),\n      u = new URL(r.startsWith(\"/\") ? t.origin + r : r),\n      f = new URLSearchParams(u.search);\n    let d = Object.fromEntries(f);\n    r.startsWith(\"/\") && (d = {\n      ...i,\n      ...d\n    });\n    let h = t.pathname;\n    return u.pathname.length > 1 && (h += u.pathname.slice(1)), {\n      ...n,\n      redirectTo: F(u.origin + h, d)\n    };\n  };\nfunction K(s, e) {\n  var t;\n  if (!e) {\n    if (typeof window == \"undefined\") return;\n    e = ((t = window.location) == null ? void 0 : t.href) || \"\";\n  }\n  s = s.replace(/[\\[\\]]/g, \"\\\\$&\");\n  const r = new RegExp(\"[?&#]\" + s + \"(=([^&#]*)|&|#|$)\"),\n    n = r.exec(e);\n  return n ? n[2] ? decodeURIComponent(n[2].replace(/\\+/g, \" \")) : \"\" : null;\n}\nfunction J(s) {\n  var r;\n  if (typeof window == \"undefined\") return;\n  const e = window == null ? void 0 : window.location;\n  if (e && e) {\n    const n = new URLSearchParams(e.search),\n      t = new URLSearchParams((r = e.hash) == null ? void 0 : r.slice(1));\n    n.delete(s), t.delete(s);\n    let i = window.location.pathname;\n    Array.from(n).length && (i += `?${n.toString()}`), Array.from(t).length && (i += `#${t.toString()}`), window.history.pushState({}, \"\", i);\n  }\n}\nconst _ = s => !!s && typeof s == \"string\" && !!String(s).toLowerCase().match(/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/),\n  B = s => !!s && typeof s == \"string\" && s.length >= we,\n  ee = s => !!s && typeof s == \"string\",\n  We = s => s && typeof s == \"string\" && s.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i),\n  He = ({\n    backendUrl: s,\n    clientUrl: e,\n    broadcastKey: r,\n    clientStorageType: n = \"web\",\n    clientStorage: t,\n    refreshIntervalTime: i,\n    autoRefreshToken: u = !0,\n    autoSignIn: f = !0\n  }) => {\n    const d = Le(n, t),\n      h = Ge(n, t),\n      E = async (a, o, c, l) => (await I(`${s}${a}`, o, c, l)).data;\n    let T = null;\n    if (typeof window != \"undefined\" && r) try {\n      T = new BroadcastChannel(r);\n    } catch {}\n    return N({\n      schema: {\n        context: {},\n        events: {},\n        services: {}\n      },\n      tsTypes: {},\n      context: $,\n      predictableActionArguments: !0,\n      id: \"nhost\",\n      type: \"parallel\",\n      states: {\n        authentication: {\n          initial: \"starting\",\n          on: {\n            SESSION_UPDATE: [{\n              cond: \"hasSession\",\n              actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\"],\n              target: \".signedIn\"\n            }]\n          },\n          states: {\n            starting: {\n              tags: [\"loading\"],\n              always: {\n                cond: \"isSignedIn\",\n                target: \"signedIn\"\n              },\n              invoke: {\n                id: \"importRefreshToken\",\n                src: \"importRefreshToken\",\n                onDone: [{\n                  cond: \"hasSession\",\n                  actions: [\"saveSession\", \"reportTokenChanged\"],\n                  target: \"signedIn\"\n                }, {\n                  target: \"signedOut\"\n                }],\n                onError: [{\n                  cond: \"shouldRetryImportToken\",\n                  actions: \"incrementTokenImportAttempts\",\n                  target: \"retryTokenImport\"\n                }, {\n                  actions: [\"saveAuthenticationError\"],\n                  target: \"signedOut\"\n                }]\n              }\n            },\n            retryTokenImport: {\n              tags: [\"loading\"],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: \"starting\"\n              }\n            },\n            signedOut: {\n              initial: \"noErrors\",\n              entry: \"reportSignedOut\",\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: [\"clearContextExceptTokens\"],\n                  exit: [\"destroyAccessToken\", \"destroyRefreshToken\", \"reportTokenChanged\"],\n                  invoke: {\n                    src: \"signout\",\n                    id: \"signingOut\",\n                    onDone: {\n                      target: \"success\"\n                    },\n                    onError: {\n                      target: \"failed\",\n                      actions: [\"saveAuthenticationError\"]\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: \"authenticating.password\",\n                SIGNIN_ANONYMOUS: \"authenticating.anonymous\",\n                SIGNIN_SECURITY_KEY_EMAIL: \"authenticating.securityKeyEmail\",\n                SIGNIN_SECURITY_KEY: \"authenticating.securityKey\",\n                SIGNIN_MFA_TOTP: \"authenticating.mfa.totp\",\n                SIGNIN_PAT: \"authenticating.pat\",\n                SIGNIN_ID_TOKEN: \"authenticating.idToken\"\n              }\n            },\n            authenticating: {\n              entry: \"resetErrors\",\n              states: {\n                password: {\n                  invoke: {\n                    src: \"signInPassword\",\n                    id: \"authenticateUserWithPassword\",\n                    onDone: [{\n                      cond: \"hasMfaTicket\",\n                      actions: [\"saveMfaTicket\"],\n                      target: \"#nhost.authentication.signedOut.needsMfa\"\n                    }, {\n                      actions: [\"saveSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    }],\n                    onError: [{\n                      cond: \"unverified\",\n                      target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                    }, {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }]\n                  }\n                },\n                pat: {\n                  invoke: {\n                    src: \"signInPAT\",\n                    id: \"authenticateWithPAT\",\n                    onDone: {\n                      actions: [\"savePATSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    },\n                    onError: {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }\n                  }\n                },\n                idToken: {\n                  invoke: {\n                    src: \"signInIdToken\",\n                    id: \"authenticateWithIdToken\",\n                    onDone: {\n                      actions: [\"saveSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    },\n                    onError: {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: \"signInAnonymous\",\n                    id: \"authenticateAnonymously\",\n                    onDone: {\n                      actions: [\"saveSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    },\n                    onError: {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: \"signInMfaTotp\",\n                        id: \"signInMfaTotp\",\n                        onDone: {\n                          actions: [\"saveSession\", \"reportTokenChanged\"],\n                          target: \"#nhost.authentication.signedIn\"\n                        },\n                        onError: {\n                          actions: [\"saveAuthenticationError\"],\n                          target: \"#nhost.authentication.signedOut.failed\"\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: \"signInSecurityKeyEmail\",\n                    id: \"authenticateUserWithSecurityKey\",\n                    onDone: {\n                      actions: [\"saveSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    },\n                    onError: [{\n                      cond: \"unverified\",\n                      target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                    }, {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }]\n                  }\n                },\n                securityKey: {\n                  invoke: {\n                    src: \"signInSecurityKey\",\n                    id: \"authenticateUserWithSecurityKey\",\n                    onDone: {\n                      actions: [\"saveSession\", \"reportTokenChanged\"],\n                      target: \"#nhost.authentication.signedIn\"\n                    },\n                    onError: [{\n                      cond: \"unverified\",\n                      target: [\"#nhost.authentication.signedOut\", \"#nhost.registration.incomplete.needsEmailVerification\"]\n                    }, {\n                      actions: \"saveAuthenticationError\",\n                      target: \"#nhost.authentication.signedOut.failed\"\n                    }]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: \"parallel\",\n              entry: [\"reportSignedIn\", \"cleanUrl\", \"broadcastToken\", \"resetErrors\"],\n              on: {\n                SIGNOUT: \"signedOut.signingOut\"\n              },\n              states: {\n                refreshTimer: {\n                  id: \"timer\",\n                  initial: \"idle\",\n                  states: {\n                    disabled: {\n                      type: \"final\"\n                    },\n                    stopped: {\n                      always: {\n                        cond: \"noToken\",\n                        target: \"idle\"\n                      }\n                    },\n                    idle: {\n                      always: [{\n                        cond: \"isAutoRefreshDisabled\",\n                        target: \"disabled\"\n                      }, {\n                        cond: \"isRefreshTokenPAT\",\n                        target: \"disabled\"\n                      }, {\n                        cond: \"hasRefreshToken\",\n                        target: \"running\"\n                      }]\n                    },\n                    running: {\n                      initial: \"pending\",\n                      entry: \"resetTimer\",\n                      states: {\n                        pending: {\n                          after: {\n                            1e3: {\n                              internal: !1,\n                              target: \"pending\"\n                            }\n                          },\n                          always: {\n                            cond: \"refreshTimerShouldRefresh\",\n                            target: \"refreshing\"\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: \"refreshToken\",\n                            id: \"refreshToken\",\n                            onDone: {\n                              actions: [\"saveSession\", \"resetTimer\", \"reportTokenChanged\", \"broadcastToken\"],\n                              target: \"pending\"\n                            },\n                            onError: [{\n                              cond: \"isUnauthorizedError\",\n                              target: \"#nhost.authentication.signedOut\"\n                            }, {\n                              actions: \"saveRefreshAttempt\",\n                              target: \"pending\"\n                            }]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: \"idle\",\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: \"running\"\n              },\n              initial: \"noErrors\",\n              states: {\n                noErrors: {},\n                error: {}\n              }\n            },\n            running: {\n              invoke: {\n                src: \"refreshToken\",\n                id: \"authenticateWithToken\",\n                onDone: {\n                  actions: [\"saveSession\", \"reportTokenChanged\", \"broadcastToken\"],\n                  target: [\"#nhost.authentication.signedIn\", \"idle.noErrors\"]\n                },\n                onError: [{\n                  cond: \"isSignedIn\",\n                  target: \"idle.error\"\n                }, {\n                  actions: \"saveAuthenticationError\",\n                  target: [\"#nhost.authentication.signedOut.failed\", \"idle.error\"]\n                }]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: \"incomplete\",\n          on: {\n            SIGNED_IN: [{\n              cond: \"isAnonymous\",\n              target: \".incomplete\"\n            }, \".complete\"]\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: \"emailPassword\",\n                SIGNUP_SECURITY_KEY: \"securityKey\",\n                PASSWORDLESS_EMAIL: \"passwordlessEmail\",\n                PASSWORDLESS_SMS: \"passwordlessSms\",\n                PASSWORDLESS_SMS_OTP: \"passwordlessSmsOtp\",\n                SIGNIN_EMAIL_OTP: \"signInEmailOTP\",\n                VERIFY_EMAIL_OTP: \"verifyEmailOTP\"\n              },\n              initial: \"noErrors\",\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"signUpEmailPassword\",\n                id: \"signUpEmailPassword\",\n                onDone: [{\n                  cond: \"hasSession\",\n                  actions: [\"saveSession\", \"reportTokenChanged\"],\n                  target: \"#nhost.authentication.signedIn\"\n                }, {\n                  actions: \"clearContext\",\n                  target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n                }],\n                onError: [{\n                  cond: \"unverified\",\n                  target: \"incomplete.needsEmailVerification\"\n                }, {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }]\n              }\n            },\n            securityKey: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"signUpSecurityKey\",\n                id: \"signUpSecurityKey\",\n                onDone: [{\n                  cond: \"hasSession\",\n                  actions: [\"saveSession\", \"reportTokenChanged\"],\n                  target: \"#nhost.authentication.signedIn\"\n                }, {\n                  actions: \"clearContext\",\n                  target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n                }],\n                onError: [{\n                  cond: \"unverified\",\n                  target: \"incomplete.needsEmailVerification\"\n                }, {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }]\n              }\n            },\n            passwordlessEmail: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"passwordlessEmail\",\n                id: \"passwordlessEmail\",\n                onDone: {\n                  actions: \"clearContext\",\n                  target: [\"#nhost.authentication.signedOut\", \"incomplete.needsEmailVerification\"]\n                },\n                onError: {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"passwordlessSms\",\n                id: \"passwordlessSms\",\n                onDone: {\n                  actions: \"clearContext\",\n                  target: [\"#nhost.authentication.signedOut\", \"incomplete.needsOtp\"]\n                },\n                onError: {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"passwordlessSmsOtp\",\n                id: \"passwordlessSmsOtp\",\n                onDone: {\n                  actions: [\"saveSession\", \"reportTokenChanged\"],\n                  target: \"#nhost.authentication.signedIn\"\n                },\n                onError: {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }\n              }\n            },\n            signInEmailOTP: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"signInEmailOTP\",\n                id: \"signInEmailOTP\",\n                onDone: {\n                  actions: \"clearContext\",\n                  target: [\"#nhost.authentication.signedOut\", \"incomplete.needsOtp\"]\n                },\n                onError: {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }\n              }\n            },\n            verifyEmailOTP: {\n              entry: [\"resetErrors\"],\n              invoke: {\n                src: \"verifyEmailOTP\",\n                id: \"verifyEmailOTP\",\n                onDone: {\n                  actions: [\"saveSession\", \"reportTokenChanged\"],\n                  target: \"#nhost.authentication.signedIn\"\n                },\n                onError: {\n                  actions: \"saveRegistrationError\",\n                  target: \"incomplete.failed\"\n                }\n              }\n            },\n            complete: {\n              on: {\n                SIGNED_OUT: \"incomplete\"\n              }\n            }\n          }\n        }\n      }\n    }, {\n      actions: {\n        reportSignedIn: w(\"SIGNED_IN\"),\n        reportSignedOut: w(\"SIGNED_OUT\"),\n        reportTokenChanged: w(\"TOKEN_CHANGED\"),\n        incrementTokenImportAttempts: g({\n          importTokenAttempts: ({\n            importTokenAttempts: a\n          }) => a + 1\n        }),\n        clearContext: g(() => (h(O, null), h(x, null), h(U, null), {\n          ...$\n        })),\n        clearContextExceptTokens: g(({\n          accessToken: a,\n          refreshToken: o\n        }) => ({\n          ...$,\n          accessToken: a,\n          refreshToken: o\n        })),\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: g({\n          user: (a, {\n            data: o\n          }) => {\n            var c;\n            return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;\n          },\n          accessToken: (a, {\n            data: o\n          }) => {\n            if (o.session) {\n              const {\n                  accessTokenExpiresIn: c,\n                  accessToken: l\n                } = o.session,\n                m = new Date(Date.now() + c * 1e3);\n              return h(O, m.toISOString()), {\n                value: l,\n                expiresAt: m,\n                expiresInSeconds: c\n              };\n            }\n            return h(O, null), {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            };\n          },\n          refreshToken: (a, {\n            data: o\n          }) => {\n            var m, y;\n            const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null,\n              l = ((y = o.session) == null ? void 0 : y.refreshTokenId) || null;\n            return c && h(x, c), l && h(U, l), {\n              value: c\n            };\n          }\n        }),\n        savePATSession: g({\n          user: (a, {\n            data: o\n          }) => {\n            var c;\n            return ((c = o == null ? void 0 : o.session) == null ? void 0 : c.user) || null;\n          },\n          accessToken: (a, {\n            data: o\n          }) => {\n            if (o.session) {\n              const {\n                  accessTokenExpiresIn: c,\n                  accessToken: l\n                } = o.session,\n                m = new Date(Date.now() + c * 1e3);\n              return h(O, m.toISOString()), {\n                value: l,\n                expiresAt: m,\n                expiresInSeconds: c\n              };\n            }\n            return h(O, null), {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            };\n          },\n          refreshToken: (a, {\n            data: o\n          }) => {\n            var m, y;\n            const c = ((m = o.session) == null ? void 0 : m.refreshToken) || null,\n              l = ((y = o.session) == null ? void 0 : y.refreshTokenId) || null;\n            return c && h(x, c), l && h(U, l), {\n              value: c,\n              isPAT: !0\n            };\n          }\n        }),\n        saveMfaTicket: g({\n          mfa: (a, o) => {\n            var c;\n            return (c = o.data) == null ? void 0 : c.mfa;\n          }\n        }),\n        resetTimer: g({\n          refreshTimer: a => ({\n            startedAt: /* @__PURE__ */new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n        saveRefreshAttempt: g({\n          refreshTimer: (a, o) => ({\n            startedAt: a.refreshTimer.startedAt,\n            attempts: a.refreshTimer.attempts + 1,\n            lastAttempt: /* @__PURE__ */new Date()\n          })\n        }),\n        // * Authentication errors\n        saveAuthenticationError: g({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({\n            errors: a\n          }, {\n            data: {\n              error: o\n            }\n          }) => ({\n            ...a,\n            authentication: o\n          })\n        }),\n        resetErrors: g({\n          errors: a => ({}),\n          importTokenAttempts: a => 0\n        }),\n        saveRegistrationError: g({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({\n            errors: a\n          }, {\n            data: {\n              error: o\n            }\n          }) => ({\n            ...a,\n            registration: o\n          })\n        }),\n        destroyRefreshToken: g({\n          refreshToken: a => (h(x, null), h(U, null), {\n            value: null\n          })\n        }),\n        destroyAccessToken: g({\n          accessToken: a => (h(O, null), {\n            value: null,\n            expiresAt: null,\n            expiresInSeconds: null\n          })\n        }),\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          f && K(\"refreshToken\") && (J(\"refreshToken\"), J(\"type\"));\n        },\n        // * Broadcast the session to other tabs when `autoSignIn` is activated\n        broadcastToken: a => {\n          if (f && r && T) try {\n            T.postMessage({\n              type: \"broadcast_session\",\n              payload: {\n                token: a.refreshToken.value,\n                accessToken: a.accessToken.value,\n                user: a.user,\n                expiresAt: a.accessToken.expiresAt ? a.accessToken.expiresAt.toISOString() : null,\n                expiresInSeconds: a.accessToken.expiresInSeconds\n              }\n            });\n          } catch {}\n        }\n      },\n      guards: {\n        isAnonymous: (a, o) => {\n          var c;\n          return !!((c = a.user) != null && c.isAnonymous);\n        },\n        isSignedIn: a => !!a.user && !!a.accessToken.value,\n        noToken: a => !a.refreshToken.value,\n        isRefreshTokenPAT: a => {\n          var o;\n          return !!((o = a.refreshToken) != null && o.isPAT);\n        },\n        hasRefreshToken: a => !!a.refreshToken.value,\n        isAutoRefreshDisabled: () => !u,\n        refreshTimerShouldRefresh: a => {\n          const {\n            expiresAt: o\n          } = a.accessToken;\n          if (!o) return !1;\n          if (a.refreshTimer.lastAttempt) return a.refreshTimer.attempts > X ? !1 : Date.now() - a.refreshTimer.lastAttempt.getTime() > Math.pow(2, a.refreshTimer.attempts - 1) * 5e3;\n          if (o.getTime() < Date.now() || i && Date.now() - a.refreshTimer.startedAt.getTime() > i * 1e3) return !0;\n          if (!a.accessToken.expiresInSeconds) return !1;\n          const l = o.getTime() - Date.now();\n          return l <= Q * 1e3 / 2 || l <= Q * 1e3 && Math.random() < 0.1;\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Should retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (a, o) => a.importTokenAttempts < X && (o.data.error.status === ie || o.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (a, {\n          data: {\n            error: o\n          }\n        }) => o.status === 401 && (\n        // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n        o.message === \"Email is not verified\" || o.error === \"unverified-user\"),\n        // * Event guards\n        hasSession: (a, o) => {\n          var c;\n          return !!((c = o.data) != null && c.session);\n        },\n        hasMfaTicket: (a, o) => {\n          var c;\n          return !!((c = o.data) != null && c.mfa);\n        },\n        isUnauthorizedError: (a, {\n          data: {\n            error: o\n          }\n        }) => o.status === 401\n      },\n      services: {\n        signInPassword: (a, {\n          email: o,\n          password: c\n        }) => _(o) ? B(c) ? E(\"/signin/email-password\", {\n          email: o,\n          password: c\n        }) : Promise.reject({\n          error: Y\n        }) : Promise.reject({\n          error: R\n        }),\n        signInPAT: (a, {\n          pat: o\n        }) => E(\"/signin/pat\", {\n          personalAccessToken: o\n        }),\n        signInIdToken: (a, {\n          provider: o,\n          idToken: c,\n          nonce: l\n        }) => E(\"/signin/idtoken\", {\n          provider: o,\n          idToken: c,\n          ...(l && {\n            nonce: l\n          })\n        }),\n        passwordlessSms: (a, {\n          phoneNumber: o,\n          options: c\n        }) => {\n          var l;\n          return ee(o) ? (l = a.user) != null && l.isAnonymous ? (console.warn(\"Deanonymisation from a phone number is not yet implemented in hasura-auth\"), E(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"sms\",\n            phoneNumber: o,\n            options: S(e, c)\n          }, a.accessToken.value)) : E(\"/signin/passwordless/sms\", {\n            phoneNumber: o,\n            options: S(e, c)\n          }) : Promise.reject({\n            error: Z\n          });\n        },\n        passwordlessSmsOtp: (a, {\n          phoneNumber: o,\n          otp: c\n        }) => ee(o) ? E(\"/signin/passwordless/sms/otp\", {\n          phoneNumber: o,\n          otp: c\n        }) : Promise.reject({\n          error: Z\n        }),\n        signInEmailOTP: (a, {\n          email: o,\n          options: c\n        }) => _(o) ? E(\"/signin/otp/email\", {\n          email: o,\n          options: S(e, c)\n        }) : Promise.reject({\n          error: R\n        }),\n        verifyEmailOTP: (a, {\n          email: o,\n          otp: c\n        }) => _(o) ? E(\"/signin/otp/email/verify\", {\n          email: o,\n          otp: c\n        }) : Promise.reject({\n          error: R\n        }),\n        passwordlessEmail: (a, {\n          email: o,\n          options: c\n        }) => {\n          var l;\n          return _(o) ? (l = a.user) != null && l.isAnonymous ? E(\"/user/deanonymize\", {\n            signInMethod: \"passwordless\",\n            connection: \"email\",\n            email: o,\n            options: S(e, c)\n          }, a.accessToken.value) : E(\"/signin/passwordless/email\", {\n            email: o,\n            options: S(e, c)\n          }) : Promise.reject({\n            error: R\n          });\n        },\n        signInAnonymous: a => E(\"/signin/anonymous\"),\n        signInMfaTotp: (a, o) => {\n          var l;\n          const c = o.ticket || ((l = a.mfa) == null ? void 0 : l.ticket);\n          return c ? We(c) ? E(\"/signin/mfa/totp\", {\n            ticket: c,\n            otp: o.otp\n          }) : Promise.reject({\n            error: Ie\n          }) : Promise.reject({\n            error: Se\n          });\n        },\n        signInSecurityKeyEmail: async (a, {\n          email: o\n        }) => {\n          if (!_(o)) throw new b(R);\n          const c = await E(\"/signin/webauthn\", {\n            email: o\n          });\n          let l;\n          try {\n            l = await j(c);\n          } catch (m) {\n            throw new b(m);\n          }\n          return E(\"/signin/webauthn/verify\", {\n            email: o,\n            credential: l\n          });\n        },\n        refreshToken: async (a, o) => {\n          const c = o.type === \"TRY_TOKEN\" ? o.token : a.refreshToken.value;\n          return {\n            session: await E(\"/token\", {\n              refreshToken: c\n            }),\n            error: null\n          };\n        },\n        signInSecurityKey: async () => {\n          try {\n            const a = await E(\"/signin/webauthn\", {});\n            let o;\n            try {\n              o = await j(a);\n            } catch (c) {\n              throw new b(c);\n            }\n            return E(\"/signin/webauthn/verify\", {\n              credential: o\n            });\n          } catch (a) {\n            throw new b(a);\n          }\n        },\n        signout: async (a, o) => {\n          const c = await E(\"/signout\", {\n            refreshToken: a.refreshToken.value,\n            all: !!o.all\n          }, o.all ? a.accessToken.value : void 0);\n          if (r && T) try {\n            T.postMessage({\n              type: \"signout\"\n            });\n          } catch {}\n          return c;\n        },\n        signUpEmailPassword: async (a, {\n          email: o,\n          password: c,\n          options: l,\n          requestOptions: m\n        }) => {\n          var y;\n          return _(o) ? B(c) ? (y = a.user) != null && y.isAnonymous ? E(\"/user/deanonymize\", {\n            signInMethod: \"email-password\",\n            email: o,\n            password: c,\n            options: S(e, l)\n          }, a.accessToken.value, m == null ? void 0 : m.headers) : E(\"/signup/email-password\", {\n            email: o,\n            password: c,\n            options: S(e, l)\n          }, null, m == null ? void 0 : m.headers) : Promise.reject({\n            error: Y\n          }) : Promise.reject({\n            error: R\n          });\n        },\n        signUpSecurityKey: async (a, {\n          email: o,\n          options: c,\n          requestOptions: l\n        }) => {\n          if (!_(o)) return Promise.reject({\n            error: R\n          });\n          const m = c == null ? void 0 : c.nickname;\n          m && delete c.nickname;\n          const y = await E(\"/signup/webauthn\", {\n            email: o,\n            options: c\n          }, null, l == null ? void 0 : l.headers);\n          let z;\n          try {\n            z = await fe(y);\n          } catch (ge) {\n            throw new b(ge);\n          }\n          return E(\"/signup/webauthn/verify\", {\n            credential: z,\n            options: {\n              redirectTo: c == null ? void 0 : c.redirectTo,\n              nickname: m,\n              displayName: c == null ? void 0 : c.displayName,\n              ...((c == null ? void 0 : c.metadata) && {\n                metadata: c == null ? void 0 : c.metadata\n              })\n            }\n          });\n        },\n        importRefreshToken: async a => {\n          if (a.user && a.refreshToken.value && a.accessToken.value && a.accessToken.expiresAt) return {\n            session: {\n              accessToken: a.accessToken.value,\n              accessTokenExpiresIn: a.accessToken.expiresAt.getTime() - Date.now(),\n              refreshToken: a.refreshToken.value,\n              user: a.user\n            },\n            error: null\n          };\n          let o = null;\n          if (f) {\n            const l = K(\"refreshToken\") || null;\n            if (l) try {\n              return {\n                session: await E(\"/token\", {\n                  refreshToken: l\n                }),\n                error: null\n              };\n            } catch (m) {\n              o = m.error;\n            } else {\n              const m = K(\"error\"),\n                y = K(\"errorDescription\");\n              if (m && y !== \"social user already exists\") return Promise.reject({\n                session: null,\n                error: {\n                  status: v,\n                  error: m,\n                  message: y || m\n                }\n              });\n            }\n          }\n          const c = await d(x);\n          if (c) try {\n            return {\n              session: await E(\"/token\", {\n                refreshToken: c\n              }),\n              error: null\n            };\n          } catch (l) {\n            o = l.error;\n          }\n          return o ? Promise.reject({\n            error: o,\n            session: null\n          }) : {\n            error: null,\n            session: null\n          };\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({\n          importTokenAttempts: a\n        }) => Math.pow(2, a - 1) * 5e3\n      }\n    });\n  },\n  Ye = ({\n    backendUrl: s,\n    clientUrl: e,\n    interpreter: r\n  }) => N({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    id: \"changeEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: g({\n        error: n => R\n      }),\n      saveRequestError: g({\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        error: (n, {\n          data: {\n            error: t\n          }\n        }) => t\n      }),\n      reportError: w(n => ({\n        type: \"ERROR\",\n        error: n.error\n      })),\n      // TODO change email in the main machine (context.user.email)\n      reportSuccess: w(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (n, {\n        email: t\n      }) => !_(t)\n    },\n    services: {\n      requestChange: async (n, {\n        email: t,\n        options: i\n      }) => (await I(`${s}/user/email/change`, {\n        newEmail: t,\n        options: S(e, i)\n      }, r == null ? void 0 : r.getSnapshot().context.accessToken.value)).data\n    }\n  }),\n  je = ({\n    backendUrl: s,\n    interpreter: e\n  }) => N({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidPassword\",\n            actions: \"saveInvalidPasswordError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidPasswordError: g({\n        error: r => Y\n      }),\n      saveRequestError: g({\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        error: (r, {\n          data: {\n            error: n\n          }\n        }) => n\n      }),\n      reportError: w(r => ({\n        type: \"ERROR\",\n        error: r.error\n      })),\n      reportSuccess: w(\"SUCCESS\")\n    },\n    guards: {\n      invalidPassword: (r, {\n        password: n\n      }) => !B(n)\n    },\n    services: {\n      requestChange: (r, {\n        password: n,\n        ticket: t\n      }) => I(`${s}/user/password`, {\n        newPassword: n,\n        ticket: t\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)\n    }\n  }),\n  kr = ({\n    backendUrl: s,\n    interpreter: e\n  }) => N({\n    schema: {\n      context: {},\n      events: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    id: \"enableMfa\",\n    initial: \"idle\",\n    context: {\n      error: null,\n      imageUrl: null,\n      secret: null\n    },\n    states: {\n      idle: {\n        initial: \"initial\",\n        on: {\n          GENERATE: \"generating\",\n          DISABLE: \"disabling\"\n        },\n        states: {\n          initial: {},\n          error: {},\n          disabled: {}\n        }\n      },\n      generating: {\n        invoke: {\n          src: \"generate\",\n          id: \"generate\",\n          onDone: {\n            target: \"generated\",\n            actions: [\"reportGeneratedSuccess\", \"saveGeneration\"]\n          },\n          onError: {\n            actions: [\"saveError\", \"reportGeneratedError\"],\n            target: \"idle.error\"\n          }\n        }\n      },\n      generated: {\n        initial: \"idle\",\n        states: {\n          idle: {\n            initial: \"idle\",\n            on: {\n              ACTIVATE: [{\n                cond: \"invalidMfaType\",\n                actions: \"saveInvalidMfaTypeError\",\n                target: \".error\"\n              }, {\n                cond: \"invalidMfaCode\",\n                actions: \"saveInvalidMfaCodeError\",\n                target: \".error\"\n              }, {\n                target: \"activating\"\n              }],\n              DISABLE: \"#enableMfa.disabling\"\n            },\n            states: {\n              idle: {},\n              error: {}\n            }\n          },\n          activating: {\n            invoke: {\n              src: \"activate\",\n              id: \"activate\",\n              onDone: {\n                target: \"activated\",\n                actions: \"reportSuccess\"\n              },\n              onError: {\n                actions: [\"saveError\", \"reportError\"],\n                target: \"idle.error\"\n              }\n            }\n          },\n          activated: {\n            type: \"final\"\n          }\n        }\n      },\n      disabling: {\n        invoke: {\n          src: \"disable\",\n          id: \"disable\",\n          onDone: {\n            target: \"idle.disabled\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidMfaTypeError: g({\n        error: r => ke\n      }),\n      saveInvalidMfaCodeError: g({\n        error: r => ye\n      }),\n      saveError: g({\n        error: (r, {\n          data: {\n            error: n\n          }\n        }) => n\n      }),\n      saveGeneration: g({\n        imageUrl: (r, {\n          data: {\n            imageUrl: n\n          }\n        }) => n,\n        secret: (r, {\n          data: {\n            totpSecret: n\n          }\n        }) => n\n      }),\n      reportError: w((r, n) => ({\n        type: \"ERROR\",\n        error: r.error\n      })),\n      reportSuccess: w(\"SUCCESS\"),\n      reportGeneratedSuccess: w(\"GENERATED\"),\n      reportGeneratedError: w(r => ({\n        type: \"GENERATED_ERROR\",\n        error: r.error\n      }))\n    },\n    guards: {\n      invalidMfaCode: (r, {\n        code: n\n      }) => !n,\n      invalidMfaType: (r, {\n        activeMfaType: n\n      }) => !n || n !== \"totp\"\n    },\n    services: {\n      generate: async r => {\n        const {\n          data: n\n        } = await $e(`${s}/mfa/totp/generate`, e == null ? void 0 : e.getSnapshot().context.accessToken.value);\n        return n;\n      },\n      activate: (r, {\n        code: n,\n        activeMfaType: t\n      }) => I(`${s}/user/mfa`, {\n        code: n,\n        activeMfaType: t\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value),\n      disable: (r, {\n        code: n\n      }) => I(`${s}/user/mfa`, {\n        code: n,\n        activeMfaType: \"\"\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value)\n    }\n  }),\n  Fe = ({\n    backendUrl: s,\n    clientUrl: e\n  }) => N({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    id: \"changePassword\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"requestChange\",\n          id: \"requestChange\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: g({\n        error: r => R\n      }),\n      saveRequestError: g({\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        error: (r, {\n          data: {\n            error: n\n          }\n        }) => n\n      }),\n      reportError: w(r => ({\n        type: \"ERROR\",\n        error: r.error\n      })),\n      reportSuccess: w(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (r, {\n        email: n\n      }) => !_(n)\n    },\n    services: {\n      requestChange: (r, {\n        email: n,\n        options: t\n      }) => I(`${s}/user/password/reset`, {\n        email: n,\n        options: S(e, t)\n      })\n    }\n  }),\n  Be = ({\n    backendUrl: s,\n    clientUrl: e\n  }) => N({\n    schema: {\n      context: {},\n      events: {},\n      services: {}\n    },\n    tsTypes: {},\n    predictableActionArguments: !0,\n    id: \"sendVerificationEmail\",\n    initial: \"idle\",\n    context: {\n      error: null\n    },\n    states: {\n      idle: {\n        on: {\n          REQUEST: [{\n            cond: \"invalidEmail\",\n            actions: \"saveInvalidEmailError\",\n            target: \".error\"\n          }, {\n            target: \"requesting\"\n          }]\n        },\n        initial: \"initial\",\n        states: {\n          initial: {},\n          success: {},\n          error: {}\n        }\n      },\n      requesting: {\n        invoke: {\n          src: \"request\",\n          id: \"request\",\n          onDone: {\n            target: \"idle.success\",\n            actions: \"reportSuccess\"\n          },\n          onError: {\n            actions: [\"saveRequestError\", \"reportError\"],\n            target: \"idle.error\"\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      saveInvalidEmailError: g({\n        error: r => R\n      }),\n      saveRequestError: g({\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        error: (r, {\n          data: {\n            error: n\n          }\n        }) => n\n      }),\n      reportError: w(r => ({\n        type: \"ERROR\",\n        error: r.error\n      })),\n      reportSuccess: w(\"SUCCESS\")\n    },\n    guards: {\n      invalidEmail: (r, {\n        email: n\n      }) => !_(n)\n    },\n    services: {\n      request: async (r, {\n        email: n,\n        options: t\n      }) => (await I(`${s}/user/email/send-verification-email`, {\n        email: n,\n        options: S(e, t)\n      })).data\n    }\n  });\nclass Ee {\n  constructor({\n    clientStorageType: e = \"web\",\n    autoSignIn: r = !0,\n    autoRefreshToken: n = !0,\n    start: t = !0,\n    backendUrl: i,\n    clientUrl: u,\n    broadcastKey: f,\n    devTools: d,\n    ...h\n  }) {\n    var E;\n    if (this._started = !1, this._subscriptionsQueue = /* @__PURE__ */new Set(), this._subscriptions = /* @__PURE__ */new Set(), this.backendUrl = i, this.clientUrl = u, this._machine = He({\n      ...h,\n      backendUrl: i,\n      clientUrl: u,\n      broadcastKey: f,\n      clientStorageType: e,\n      autoSignIn: r,\n      autoRefreshToken: n\n    }), t && this.start({\n      devTools: d\n    }), typeof window != \"undefined\" && f) try {\n      this._channel = new BroadcastChannel(f), r && ((E = this._channel) == null || E.addEventListener(\"message\", T => {\n        var c;\n        const {\n          type: a,\n          payload: o\n        } = T.data;\n        if (a === \"broadcast_session\") {\n          const l = (c = this.interpreter) == null ? void 0 : c.getSnapshot().context,\n            m = l == null ? void 0 : l.refreshToken.value;\n          this.interpreter && o.token && o.token !== m && this.interpreter.send(\"SESSION_UPDATE\", {\n            data: {\n              session: {\n                user: o.user,\n                accessToken: o.accessToken,\n                refreshToken: o.token,\n                accessTokenExpiresIn: o.expiresInSeconds\n              }\n            }\n          });\n        }\n      })), this._channel.addEventListener(\"message\", T => {\n        const {\n          type: a\n        } = T.data;\n        a === \"signout\" && this.interpreter && this.interpreter.send(\"SIGNOUT\");\n      });\n    } catch {}\n  }\n  start({\n    devTools: e = !1,\n    initialSession: r,\n    interpreter: n\n  } = {}) {\n    var u, f;\n    const t = {\n      ...this.machine.context,\n      accessToken: {\n        ...this.machine.context.accessToken\n      },\n      refreshToken: {\n        ...this.machine.context.refreshToken\n      }\n    };\n    r && (t.user = r.user, t.refreshToken.value = (u = r.refreshToken) != null ? u : null, t.accessToken.value = (f = r.accessToken) != null ? f : null, t.accessToken.expiresAt = new Date(Date.now() + r.accessTokenExpiresIn * 1e3));\n    const i = this.machine.withContext(t);\n    this._interpreter || (this._interpreter = n || C(i, {\n      devTools: e\n    })), (!this._started || typeof window == \"undefined\") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach(d => d())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach(d => d(this))), this._started = !0;\n  }\n  get machine() {\n    return this._machine;\n  }\n  get interpreter() {\n    return this._interpreter;\n  }\n  get started() {\n    return this._started;\n  }\n  subscribe(e) {\n    if (this.started) {\n      const r = e(this);\n      return this._subscriptions.add(r), r;\n    } else return this._subscriptionsQueue.add(e), () => {\n      console.log(\"onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.\");\n    };\n  }\n}\nclass qe extends Ee {\n  constructor({\n    ...e\n  }) {\n    super({\n      ...e,\n      autoSignIn: L() && e.autoSignIn,\n      autoRefreshToken: L() && e.autoRefreshToken,\n      clientStorageType: \"cookie\"\n    });\n  }\n}\nconst yr = qe,\n  ze = async ({\n    backendUrl: s,\n    interpreter: e\n  }, r) => {\n    try {\n      const {\n        data: n\n      } = await I(`${s}/user/webauthn/add`, {}, e == null ? void 0 : e.getSnapshot().context.accessToken.value);\n      let t;\n      try {\n        t = await fe(n);\n      } catch (u) {\n        throw new b(u);\n      }\n      const {\n        data: i\n      } = await I(`${s}/user/webauthn/verify`, {\n        credential: t,\n        nickname: r\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);\n      return {\n        key: i,\n        isError: !1,\n        error: null,\n        isSuccess: !0\n      };\n    } catch (n) {\n      const {\n        error: t\n      } = n;\n      return {\n        isError: !0,\n        error: t,\n        isSuccess: !1\n      };\n    }\n  },\n  Qe = async (s, e, r) => new Promise(n => {\n    s.send(\"REQUEST\", {\n      email: e,\n      options: r\n    }), s.onTransition(t => {\n      t.matches({\n        idle: \"error\"\n      }) ? n({\n        error: t.context.error,\n        isError: !0,\n        needsEmailVerification: !1\n      }) : t.matches({\n        idle: \"success\"\n      }) && n({\n        error: null,\n        isError: !1,\n        needsEmailVerification: !0\n      });\n    });\n  }),\n  Xe = async (s, e, r) => new Promise(n => {\n    s.send(\"REQUEST\", {\n      password: e,\n      ticket: r\n    }), s.onTransition(t => {\n      t.matches({\n        idle: \"error\"\n      }) ? n({\n        error: t.context.error,\n        isError: !0,\n        isSuccess: !1\n      }) : t.matches({\n        idle: \"success\"\n      }) && n({\n        error: null,\n        isError: !1,\n        isSuccess: !0\n      });\n    });\n  }),\n  Ir = s => new Promise(e => {\n    s.send(\"GENERATE\"), s.onTransition(r => {\n      r.matches(\"generated\") ? e({\n        error: null,\n        isError: !1,\n        isGenerated: !0,\n        qrCodeDataUrl: r.context.imageUrl || \"\",\n        totpSecret: r.context.secret\n      }) : r.matches({\n        idle: \"error\"\n      }) && e({\n        error: r.context.error || null,\n        isError: !0,\n        isGenerated: !1,\n        qrCodeDataUrl: \"\",\n        totpSecret: r.context.secret\n      });\n    });\n  }),\n  Sr = (s, e) => new Promise(r => {\n    s.send(\"ACTIVATE\", {\n      activeMfaType: \"totp\",\n      code: e\n    }), s.onTransition(n => {\n      n.matches({\n        generated: \"activated\"\n      }) ? r({\n        error: null,\n        isActivated: !0,\n        isError: !1\n      }) : n.matches({\n        generated: {\n          idle: \"error\"\n        }\n      }) && r({\n        error: n.context.error,\n        isActivated: !1,\n        isError: !0\n      });\n    });\n  }),\n  Ar = (s, e) => new Promise(r => {\n    s.send(\"DISABLE\", {\n      code: e\n    }), s.onTransition(n => {\n      n.matches({\n        idle: \"disabled\"\n      }) ? r({\n        error: null,\n        isDisabled: !0,\n        isError: !1\n      }) : n.matches({\n        idle: \"error\"\n      }) && r({\n        error: n.context.error,\n        isDisabled: !1,\n        isError: !0\n      });\n    });\n  }),\n  Ze = async (s, e, r) => new Promise(n => {\n    s.send(\"REQUEST\", {\n      email: e,\n      options: r\n    }), s.onTransition(t => {\n      t.matches({\n        idle: \"error\"\n      }) ? n({\n        error: t.context.error,\n        isError: !0,\n        isSent: !1\n      }) : t.matches({\n        idle: \"success\"\n      }) && n({\n        error: null,\n        isError: !1,\n        isSent: !0\n      });\n    });\n  }),\n  Je = (s, e, r) => new Promise(n => {\n    s.send(\"REQUEST\", {\n      email: e,\n      options: r\n    }), s.onTransition(t => {\n      t.matches({\n        idle: \"error\"\n      }) ? n({\n        error: t.context.error,\n        isError: !0,\n        isSent: !1\n      }) : t.matches({\n        idle: \"success\"\n      }) && n({\n        error: null,\n        isError: !1,\n        isSent: !0\n      });\n    });\n  }),\n  er = s => new Promise(e => {\n    const {\n      changed: r\n    } = s.send(\"SIGNIN_ANONYMOUS\");\n    r || e({\n      isSuccess: !1,\n      isError: !0,\n      error: k,\n      user: null,\n      accessToken: null,\n      refreshToken: null\n    }), s.onTransition(n => {\n      n.matches({\n        authentication: \"signedIn\"\n      }) && e({\n        isSuccess: !0,\n        isError: !1,\n        error: null,\n        user: n.context.user,\n        accessToken: n.context.accessToken.value,\n        refreshToken: n.context.refreshToken.value\n      }), n.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      }) && e({\n        isSuccess: !1,\n        isError: !0,\n        error: n.context.errors.authentication || null,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      });\n    });\n  }),\n  rr = (s, e, r) => new Promise(n => {\n    const {\n      changed: t,\n      context: i\n    } = s.send(\"SIGNIN_PASSWORD\", {\n      email: e,\n      password: r\n    });\n    if (!t) return n({\n      accessToken: i.accessToken.value,\n      refreshToken: i.refreshToken.value,\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      needsEmailVerification: !1,\n      needsMfaOtp: !1,\n      mfa: null,\n      user: i.user\n    });\n    s.onTransition(u => {\n      u.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) ? n({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !0,\n        needsMfaOtp: !1,\n        mfa: null,\n        user: null\n      }) : u.matches({\n        authentication: {\n          signedOut: \"needsMfa\"\n        }\n      }) ? n({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        needsMfaOtp: !0,\n        mfa: u.context.mfa,\n        user: null\n      }) : u.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      }) ? n({\n        accessToken: null,\n        refreshToken: null,\n        error: u.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        needsMfaOtp: !1,\n        mfa: null,\n        user: null\n      }) : u.matches({\n        authentication: \"signedIn\"\n      }) && n({\n        accessToken: u.context.accessToken.value,\n        refreshToken: u.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsEmailVerification: !1,\n        needsMfaOtp: !1,\n        mfa: null,\n        user: u.context.user\n      });\n    });\n  }),\n  re = (s, e, r) => new Promise(n => {\n    const {\n      changed: t\n    } = s.send(\"PASSWORDLESS_EMAIL\", {\n      email: e,\n      options: r\n    });\n    if (!t) return n({\n      error: k,\n      isError: !0,\n      isSuccess: !1\n    });\n    s.onTransition(i => {\n      i.matches(\"registration.incomplete.failed\") ? n({\n        error: i.context.errors.registration || null,\n        isError: !0,\n        isSuccess: !1\n      }) : i.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) && n({\n        error: null,\n        isError: !1,\n        isSuccess: !0\n      });\n    });\n  }),\n  nr = (s, e) => new Promise(r => {\n    const {\n      changed: n,\n      context: t\n    } = s.send({\n      type: \"SIGNIN_SECURITY_KEY_EMAIL\",\n      email: e\n    });\n    if (!n) return r({\n      accessToken: t.accessToken.value,\n      refreshToken: t.refreshToken.value,\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      needsEmailVerification: !1,\n      user: t.user\n    });\n    s.onTransition(i => {\n      i.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) ? r({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !0,\n        user: null\n      }) : i.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      }) ? r({\n        accessToken: null,\n        refreshToken: null,\n        error: i.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        user: null\n      }) : i.matches({\n        authentication: \"signedIn\"\n      }) && r({\n        accessToken: i.context.accessToken.value,\n        refreshToken: i.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsEmailVerification: !1,\n        user: i.context.user\n      });\n    });\n  });\nfunction ne(s) {\n  return {\n    error: s.message || \"Something went wrong!\",\n    status: s.status || 1,\n    message: s.message || \"Something went wrong!\"\n  };\n}\nconst sr = async (s, e) => {\n    var u, f;\n    const r = (u = s.interpreter) == null ? void 0 : u.getSnapshot(),\n      n = r == null ? void 0 : r.context.accessToken.value;\n    let t;\n    try {\n      t = (await I(`${s.backendUrl}/elevate/webauthn`, {\n        email: e\n      }, n)).data;\n    } catch (d) {\n      return {\n        error: ne(d),\n        isError: !0,\n        isSuccess: !1,\n        elevated: !1\n      };\n    }\n    let i;\n    try {\n      i = await j(t);\n    } catch (d) {\n      return {\n        error: ne(d),\n        isError: !0,\n        isSuccess: !1,\n        elevated: !1\n      };\n    }\n    try {\n      const {\n        data: {\n          session: d\n        },\n        error: h\n      } = await I(`${s.backendUrl}/elevate/webauthn/verify`, {\n        email: e,\n        credential: i\n      }, n);\n      return d && !h ? ((f = s.interpreter) == null || f.send({\n        type: \"SESSION_UPDATE\",\n        data: {\n          session: d\n        }\n      }), {\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        elevated: !0\n      }) : {\n        error: h,\n        isError: !0,\n        isSuccess: !1,\n        elevated: !1\n      };\n    } catch (d) {\n      const {\n        error: h\n      } = d;\n      return {\n        error: h,\n        isError: !0,\n        isSuccess: !1,\n        elevated: !1\n      };\n    }\n  },\n  tr = (s, e, r) => new Promise(n => {\n    const {\n      changed: t,\n      context: i\n    } = s.send(\"SIGNIN_MFA_TOTP\", {\n      otp: e,\n      ticket: r\n    });\n    if (!t) return n({\n      accessToken: i.accessToken.value,\n      refreshToken: i.refreshToken.value,\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      user: i.user\n    });\n    s.onTransition(u => {\n      u.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      }) ? n({\n        accessToken: null,\n        refreshToken: null,\n        error: u.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        user: null\n      }) : u.matches({\n        authentication: \"signedIn\"\n      }) && n({\n        accessToken: u.context.accessToken.value,\n        refreshToken: u.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        user: u.context.user\n      });\n    });\n  }),\n  ir = (s, e) => new Promise(r => {\n    const {\n      changed: n\n    } = s.send(\"SIGNIN_PAT\", {\n      pat: e\n    });\n    n || r({\n      isSuccess: !1,\n      isError: !0,\n      error: k,\n      user: null,\n      accessToken: null,\n      refreshToken: null\n    }), s.onTransition(t => {\n      if (t.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) return r({\n        accessToken: null,\n        refreshToken: null,\n        user: null,\n        error: t.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1\n      });\n      if (t.matches({\n        authentication: \"signedIn\"\n      })) return r({\n        accessToken: t.context.accessToken.value,\n        refreshToken: t.context.refreshToken.value,\n        user: t.context.user,\n        error: null,\n        isError: !1,\n        isSuccess: !0\n      });\n    });\n  }),\n  se = (s, e, r) => new Promise(n => {\n    const {\n      changed: t\n    } = s.send(\"PASSWORDLESS_SMS\", {\n      phoneNumber: e,\n      options: r\n    });\n    if (!t) return n({\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      needsOtp: !1\n    });\n    s.onTransition(i => {\n      i.matches(\"registration.incomplete.needsOtp\") ? n({\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsOtp: !0\n      }) : i.matches(\"registration.incomplete.failed\") && n({\n        error: i.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        needsOtp: !1\n      });\n    });\n  }),\n  or = (s, e, r) => new Promise(n => {\n    const {\n      changed: t\n    } = s.send({\n      type: \"PASSWORDLESS_SMS_OTP\",\n      phoneNumber: e,\n      otp: r\n    });\n    if (!t) return n({\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      user: null,\n      accessToken: null,\n      refreshToken: null\n    });\n    s.onTransition(i => {\n      i.matches({\n        authentication: \"signedIn\"\n      }) ? n({\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        user: i.context.user,\n        accessToken: i.context.accessToken.value,\n        refreshToken: i.context.refreshToken.value\n      }) : i.matches({\n        registration: {\n          incomplete: \"failed\"\n        }\n      }) && n({\n        error: i.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      });\n    });\n  }),\n  ar = async (s, e) => new Promise(r => {\n    const {\n      event: n\n    } = s.send(\"SIGNOUT\", {\n      all: e\n    });\n    if (n.type !== \"SIGNED_OUT\") return r({\n      isSuccess: !1,\n      isError: !0,\n      error: _e\n    });\n    s.onTransition(t => {\n      t.matches({\n        authentication: {\n          signedOut: \"success\"\n        }\n      }) ? r({\n        isSuccess: !0,\n        isError: !1,\n        error: null\n      }) : t.matches(\"authentication.signedOut.failed\") && r({\n        isSuccess: !1,\n        isError: !0,\n        error: t.context.errors.signout || null\n      });\n    });\n  }),\n  te = (s, e, r, n, t) => new Promise(i => {\n    const {\n      changed: u,\n      context: f\n    } = s.send(\"SIGNUP_EMAIL_PASSWORD\", {\n      email: e,\n      password: r,\n      options: n,\n      requestOptions: t\n    });\n    if (!u) return i({\n      error: k,\n      accessToken: f.accessToken.value,\n      refreshToken: f.refreshToken.value,\n      isError: !0,\n      isSuccess: !1,\n      needsEmailVerification: !1,\n      user: f.user\n    });\n    s.onTransition(d => {\n      d.matches(\"registration.incomplete.failed\") ? i({\n        accessToken: null,\n        refreshToken: null,\n        error: d.context.errors.registration || null,\n        isError: !0,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        user: null\n      }) : d.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) ? i({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !0,\n        user: null\n      }) : d.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      }) && i({\n        accessToken: d.context.accessToken.value,\n        refreshToken: d.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsEmailVerification: !1,\n        user: d.context.user\n      });\n    });\n  }),\n  cr = (s, e, r, n) => new Promise(t => {\n    const {\n      changed: i,\n      context: u\n    } = s.send(\"SIGNUP_SECURITY_KEY\", {\n      email: e,\n      options: r,\n      requestOptions: n\n    });\n    if (!i) return t({\n      error: k,\n      accessToken: u.accessToken.value,\n      refreshToken: u.refreshToken.value,\n      isError: !0,\n      isSuccess: !1,\n      needsEmailVerification: !1,\n      user: u.user\n    });\n    s.onTransition(f => {\n      f.matches(\"registration.incomplete.failed\") ? t({\n        accessToken: null,\n        refreshToken: null,\n        error: f.context.errors.registration || null,\n        isError: !0,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        user: null\n      }) : f.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) ? t({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !0,\n        user: null\n      }) : f.matches({\n        authentication: \"signedIn\",\n        registration: \"complete\"\n      }) && t({\n        accessToken: f.context.accessToken.value,\n        refreshToken: f.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsEmailVerification: !1,\n        user: f.context.user\n      });\n    });\n  }),\n  ur = (s, e, r) => new Promise(n => {\n    const {\n      changed: t\n    } = s.send(\"SIGNIN_EMAIL_OTP\", {\n      email: e,\n      options: r\n    });\n    if (!t) return n({\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      needsOtp: !1\n    });\n    s.onTransition(i => {\n      i.matches(\"registration.incomplete.needsOtp\") ? n({\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsOtp: !0\n      }) : i.matches(\"registration.incomplete.failed\") && n({\n        error: i.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        needsOtp: !1\n      });\n    });\n  }),\n  lr = (s, e, r) => new Promise(n => {\n    const {\n      changed: t\n    } = s.send({\n      type: \"VERIFY_EMAIL_OTP\",\n      email: e,\n      otp: r\n    });\n    if (!t) return n({\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      user: null,\n      accessToken: null,\n      refreshToken: null\n    });\n    s.onTransition(i => {\n      i.matches({\n        authentication: \"signedIn\"\n      }) ? n({\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        user: i.context.user,\n        accessToken: i.context.accessToken.value,\n        refreshToken: i.context.refreshToken.value\n      }) : i.matches({\n        registration: {\n          incomplete: \"failed\"\n        }\n      }) && n({\n        error: i.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      });\n    });\n  }),\n  dr = (s, {\n    provider: e,\n    idToken: r,\n    nonce: n\n  }) => new Promise(t => {\n    const {\n      changed: i\n    } = s.send(\"SIGNIN_ID_TOKEN\", {\n      provider: e,\n      idToken: r,\n      ...(n && {\n        nonce: n\n      })\n    });\n    i || t({\n      isSuccess: !1,\n      isError: !0,\n      error: k,\n      user: null,\n      accessToken: null,\n      refreshToken: null\n    }), s.onTransition(u => {\n      if (u.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      })) return t({\n        accessToken: null,\n        refreshToken: null,\n        user: null,\n        error: u.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1\n      });\n      if (u.matches({\n        authentication: \"signedIn\"\n      })) return t({\n        accessToken: u.context.accessToken.value,\n        refreshToken: u.context.refreshToken.value,\n        user: u.context.user,\n        error: null,\n        isError: !1,\n        isSuccess: !0\n      });\n    });\n  }),\n  fr = async ({\n    backendUrl: s,\n    interpreter: e\n  }, {\n    provider: r,\n    idToken: n,\n    nonce: t\n  }) => {\n    try {\n      return await I(`${s}/link/idtoken`, {\n        provider: r,\n        idToken: n,\n        ...(t && {\n          nonce: t\n        })\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value), {\n        isError: !1,\n        error: null,\n        isSuccess: !0\n      };\n    } catch (i) {\n      const {\n        error: u\n      } = i;\n      return {\n        isError: !0,\n        error: u,\n        isSuccess: !1\n      };\n    }\n  },\n  hr = s => new Promise(e => {\n    const {\n      changed: r,\n      context: n\n    } = s.send({\n      type: \"SIGNIN_SECURITY_KEY\"\n    });\n    if (!r) return e({\n      accessToken: n.accessToken.value,\n      refreshToken: n.refreshToken.value,\n      error: k,\n      isError: !0,\n      isSuccess: !1,\n      needsEmailVerification: !1,\n      user: n.user\n    });\n    s.onTransition(t => {\n      t.matches({\n        authentication: {\n          signedOut: \"noErrors\"\n        },\n        registration: {\n          incomplete: \"needsEmailVerification\"\n        }\n      }) ? e({\n        accessToken: null,\n        refreshToken: null,\n        error: null,\n        isError: !1,\n        isSuccess: !1,\n        needsEmailVerification: !0,\n        user: null\n      }) : t.matches({\n        authentication: {\n          signedOut: \"failed\"\n        }\n      }) ? e({\n        accessToken: null,\n        refreshToken: null,\n        error: t.context.errors.authentication || null,\n        isError: !0,\n        isSuccess: !1,\n        needsEmailVerification: !1,\n        user: null\n      }) : t.matches({\n        authentication: \"signedIn\"\n      }) && e({\n        accessToken: t.context.accessToken.value,\n        refreshToken: t.context.refreshToken.value,\n        error: null,\n        isError: !1,\n        isSuccess: !0,\n        needsEmailVerification: !1,\n        user: t.context.user\n      });\n    });\n  }),\n  mr = async ({\n    backendUrl: s,\n    interpreter: e\n  }, {\n    expiresAt: r,\n    metadata: n\n  }) => {\n    try {\n      const {\n        data: t\n      } = await I(`${s}/pat`, {\n        expiresAt: r.toISOString(),\n        metadata: n\n      }, e == null ? void 0 : e.getSnapshot().context.accessToken.value);\n      return {\n        data: t ? {\n          id: t.id || null,\n          personalAccessToken: t.personalAccessToken || null\n        } : null,\n        isError: !1,\n        error: null,\n        isSuccess: !0\n      };\n    } catch (t) {\n      const {\n        error: i\n      } = t;\n      return {\n        isError: !0,\n        error: i,\n        isSuccess: !1,\n        data: null\n      };\n    }\n  };\nclass Rr {\n  constructor({\n    url: e,\n    broadcastKey: r,\n    autoRefreshToken: n = !0,\n    autoSignIn: t = !0,\n    clientStorage: i,\n    clientStorageType: u,\n    refreshIntervalTime: f,\n    start: d = !0\n  }) {\n    var h;\n    this.url = e, this._client = new Ee({\n      backendUrl: e,\n      clientUrl: typeof window != \"undefined\" && ((h = window.location) == null ? void 0 : h.origin) || \"\",\n      broadcastKey: r,\n      autoRefreshToken: n,\n      autoSignIn: t,\n      start: d,\n      clientStorage: i,\n      clientStorageType: u,\n      refreshIntervalTime: f\n    });\n  }\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(e, r) {\n    const n = await this.waitUntilReady();\n    if (\"securityKey\" in e) {\n      const {\n        email: f,\n        options: d\n      } = e;\n      return A(await cr(n, f, d, r));\n    }\n    const {\n      email: t,\n      password: i,\n      options: u\n    } = e;\n    return A(await te(n, t, i, u, r));\n  }\n  /**\n   * Use `nhost.auth.connectProvider` to connect a social authentication provider to an existing user account\n   *\n   * @example\n   * ### Connect an authentication provider to an existing user account\n   * ```ts\n   * nhost.auth.connectProvider({\n   *   provider: 'github\n   *   options: {\n   *    redirectTo: window.location.href\n   *   }\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/connect-provider\n   */\n  async connectProvider(e) {\n    const n = (await this.waitUntilReady()).getSnapshot().context.accessToken.value,\n      {\n        provider: t,\n        options: i\n      } = e,\n      u = F(`${this._client.backendUrl}/signin/provider/${t}`, S(this._client.clientUrl, {\n        ...i,\n        connect: n\n      }));\n    return L() && (window.location.href = u), {\n      providerUrl: u\n    };\n  }\n  /**\n   * Use `nhost.auth.signInIdToken` to sign in a user with the provider's account using an ID token\n   *\n   * @example\n   * ### Sign in a user with an id token\n   * ```ts\n   * nhost.auth.signInIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-idtoken\n   */\n  async signInIdToken(e) {\n    const r = await this.waitUntilReady(),\n      n = await dr(r, e);\n    return {\n      ...A(n),\n      mfa: null\n    };\n  }\n  /**\n   * Use `nhost.auth.linkIdToken` to link a user account with the provider's account using an ID token\n   *\n   * @example\n   * ### Link a user account with the provider's account using an id token\n   * ```ts\n   * nhost.auth.linkIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/link-idtoken\n   */\n  async linkIdToken(e) {\n    return fr(this._client, e);\n  }\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(e) {\n    const r = await this.waitUntilReady();\n    if (!e) {\n      const n = await er(r);\n      return {\n        ...A(n),\n        mfa: null\n      };\n    }\n    if (\"provider\" in e) {\n      const {\n          provider: n,\n          options: t\n        } = e,\n        i = F(`${this._client.backendUrl}/signin/provider/${n}`, S(this._client.clientUrl, t));\n      return L() && (window.location.href = i), {\n        providerUrl: i,\n        provider: n,\n        session: null,\n        mfa: null,\n        error: null\n      };\n    }\n    if (\"email\" in e && \"password\" in e) {\n      const n = await rr(r, e.email, e.password);\n      return n.needsEmailVerification ? {\n        session: null,\n        mfa: null,\n        error: ve\n      } : n.needsMfaOtp ? {\n        session: null,\n        mfa: n.mfa,\n        error: null\n      } : {\n        ...A(n),\n        mfa: null\n      };\n    }\n    if (\"email\" in e && \"securityKey\" in e) {\n      if (e.securityKey !== !0) throw Error(\"securityKey must be true\");\n      const n = await nr(r, e.email);\n      return {\n        ...A(n),\n        mfa: null\n      };\n    }\n    if (\"email\" in e) {\n      const {\n          email: n,\n          options: t\n        } = e,\n        {\n          error: i\n        } = await re(r, n, t);\n      return {\n        session: null,\n        mfa: null,\n        error: i\n      };\n    }\n    if (\"phoneNumber\" in e && \"otp\" in e) {\n      const n = await or(r, e.phoneNumber, e.otp);\n      return {\n        ...A(n),\n        mfa: null\n      };\n    }\n    if (\"phoneNumber\" in e) {\n      const {\n        error: n\n      } = await se(r, e.phoneNumber, e.options);\n      return {\n        error: n,\n        mfa: null,\n        session: null\n      };\n    }\n    if (\"otp\" in e) {\n      const n = await tr(r, e.otp, e.ticket);\n      return {\n        ...A(n),\n        mfa: null\n      };\n    }\n    return {\n      error: Oe,\n      mfa: null,\n      session: null\n    };\n  }\n  /**\n   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat\n   *\n   * @param personalAccessToken - The personal access token to sign in with\n   */\n  async signInPAT(e) {\n    const r = await this.waitUntilReady(),\n      n = await ir(r, e);\n    return A(n);\n  }\n  /**\n   * Use `nhost.auth.signInEmailOTP` to sign in with an email one-time password (OTP).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInEmailOTP('user@example.com')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-email-otp\n   *\n   * @param email - The email address to send the OTP to\n   */\n  async signInEmailOTP(e, r) {\n    const n = await this.waitUntilReady(),\n      {\n        error: t\n      } = await ur(n, e, r);\n    return {\n      error: t,\n      session: null,\n      mfa: null\n    };\n  }\n  /**\n   * Use `nhost.auth.verifyEmailOTP` to verify an email one-time password (OTP) and complete the sign-in process\n   *\n   * @example\n   * ```ts\n   * nhost.auth.verifyEmailOTP('user@example.com', '123456')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/verify-email-otp\n   *\n   * @param email - The email address to verify the OTP for\n   * @param otp - The one-time password sent to the email address\n   */\n  async verifyEmailOTP(e, r) {\n    const n = await this.waitUntilReady(),\n      t = await lr(n, e, r);\n    return {\n      ...A(t),\n      mfa: null\n    };\n  }\n  /**\n   * Use `nhost.auth.signInSecurityKey` to sign in a user with a security key using the WebAuthn API\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInSecurityKey()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-security-key\n   */\n  async signInSecurityKey() {\n    const e = await this.waitUntilReady(),\n      r = await hr(e);\n    return {\n      ...A(r),\n      mfa: null\n    };\n  }\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(e) {\n    const r = await this.waitUntilReady(),\n      {\n        error: n\n      } = await ar(r, e == null ? void 0 : e.all);\n    return {\n      error: n\n    };\n  }\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({\n    email: e,\n    options: r\n  }) {\n    const n = C(Fe(this._client)).start(),\n      {\n        error: t\n      } = await Ze(n, e, r);\n    return {\n      error: t\n    };\n  }\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword: e,\n    ticket: r\n  }) {\n    const n = C(je(this._client)).start(),\n      {\n        error: t\n      } = await Xe(n, e, r);\n    return {\n      error: t\n    };\n  }\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email: e,\n    options: r\n  }) {\n    const n = C(Be(this._client)).start(),\n      {\n        error: t\n      } = await Je(n, e, r);\n    return {\n      error: t\n    };\n  }\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({\n    newEmail: e,\n    options: r\n  }) {\n    const n = C(Ye(this._client)).start(),\n      {\n        error: t\n      } = await Qe(n, e, r);\n    return {\n      error: t\n    };\n  }\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(e) {\n    const r = await this.waitUntilReady();\n    if (e.signInMethod === \"passwordless\") {\n      if (e.connection === \"email\") {\n        const {\n          error: n\n        } = await re(r, e.email, e.options);\n        return {\n          error: n\n        };\n      }\n      if (e.connection === \"sms\") {\n        const {\n          error: n\n        } = await se(r, e.phoneNumber, e.options);\n        return {\n          error: n\n        };\n      }\n    }\n    if (e.signInMethod === \"email-password\") {\n      const {\n        error: n\n      } = await te(r, e.email, e.password, e.options);\n      return {\n        error: n\n      };\n    }\n    throw Error(\"Unknown deanonymization method\");\n  }\n  /**\n   * Use `nhost.auth.addSecurityKey` to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(e) {\n    const {\n      error: r,\n      key: n\n    } = await ze(this._client, e);\n    return {\n      error: r,\n      key: n\n    };\n  }\n  /**\n   * Use `nhost.auth.elevateEmailSecurityKey` to get a temporary elevated auth permissions to run sensitive operations.\n   * @param email user email\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/elevate-email-security-key\n   */\n  async elevateEmailSecurityKey(e) {\n    if (!e) throw Error(\"A user email is required\");\n    return {\n      ...(await sr(this._client, e)),\n      mfa: null\n    };\n  }\n  /**\n   * Use `nhost.auth.createPAT` to create a personal access token for the user.\n   *\n   * @param expiresAt Expiration date for the token\n   * @param metadata Optional metadata to store with the token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat\n   */\n  async createPAT(e, r) {\n    return mr(this._client, {\n      expiresAt: e,\n      metadata: r\n    });\n  }\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(e) {\n    return this._client.subscribe(() => {\n      var n;\n      const r = (n = this._client.interpreter) == null ? void 0 : n.onTransition(({\n        event: t,\n        context: i\n      }) => {\n        t.type === \"TOKEN_CHANGED\" && e(M(i));\n      });\n      return () => r == null ? void 0 : r.stop();\n    });\n  }\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(e) {\n    return this._client.subscribe(() => {\n      var n;\n      const r = (n = this._client.interpreter) == null ? void 0 : n.onTransition(({\n        event: t,\n        context: i\n      }) => {\n        (t.type === \"SIGNED_IN\" || t.type === \"SIGNED_OUT\") && e(t.type, M(i));\n      });\n      return () => r == null ? void 0 : r.stop();\n    });\n  }\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated() {\n    var e;\n    return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({\n      authentication: \"signedIn\"\n    }));\n  }\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync() {\n    return (await this.waitUntilReady()).getSnapshot().matches({\n      authentication: \"signedIn\"\n    });\n  }\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus() {\n    var r;\n    const e = ((r = this.client.interpreter) == null ? void 0 : r.getSnapshot().context.importTokenAttempts) || 0;\n    return this.isReady() ? {\n      isAuthenticated: this.isAuthenticated(),\n      isLoading: !1,\n      connectionAttempts: e\n    } : {\n      isAuthenticated: !1,\n      isLoading: !0,\n      connectionAttempts: e\n    };\n  }\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken() {\n    var e, r;\n    return (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? r : void 0;\n  }\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  getDecodedAccessToken() {\n    const e = this.getAccessToken();\n    return e ? Te(e) : null;\n  }\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  getHasuraClaims() {\n    var e;\n    return ((e = this.getDecodedAccessToken()) == null ? void 0 : e[\"https://hasura.io/jwt/claims\"]) || null;\n  }\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHasuraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  getHasuraClaim(e) {\n    var r;\n    return ((r = this.getHasuraClaims()) == null ? void 0 : r[e.startsWith(\"x-hasura-\") ? e : `x-hasura-${e}`]) || null;\n  }\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshSession();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshSession(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(e) {\n    try {\n      const r = await this.waitUntilReady();\n      return new Promise(n => {\n        const t = e || r.getSnapshot().context.refreshToken.value;\n        if (!t) return n({\n          session: null,\n          error: Ae\n        });\n        const {\n          changed: i\n        } = r.send(\"TRY_TOKEN\", {\n          token: t\n        });\n        if (!i) return n({\n          session: null,\n          error: Re\n        });\n        r.onTransition(u => {\n          u.matches({\n            token: {\n              idle: \"error\"\n            }\n          }) ? n({\n            session: null,\n            // * TODO get the error from xstate once it is implemented\n            error: Pe\n          }) : u.event.type === \"TOKEN_CHANGED\" && n({\n            session: M(u.context),\n            error: null\n          });\n        });\n      });\n    } catch (r) {\n      return {\n        session: null,\n        error: r.message\n      };\n    }\n  }\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    var e, r;\n    return M((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context);\n  }\n  /**\n   * Initialize the auth client with an existing session\n   *\n   * @example\n   * ### Initialize with an existing Nhost session\n   * ```ts\n   * await nhost.auth.initWithSession({ session: initialSession })\n   * ```\n   *\n   * @param session - The Nhost session object to initialize the client with\n   * @docs https://docs.nhost.io/reference/javascript/auth/init-with-session\n   */\n  async initWithSession({\n    session: e\n  }) {\n    this.client.start({\n      initialSession: e\n    }), await this.waitUntilReady();\n  }\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    var e, r, n;\n    return ((n = (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context) == null ? void 0 : n.user) || null;\n  }\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  waitUntilReady() {\n    const r = this._client.interpreter;\n    if (!r) throw Error(\"Auth interpreter not set\");\n    return r.getSnapshot().hasTag(\"loading\") ? new Promise((n, t) => {\n      let i = setTimeout(() => t(\"The state machine is not yet ready after 15 seconds.\"), 15e3);\n      r.onTransition(u => {\n        if (!u.hasTag(\"loading\")) return clearTimeout(i), n(r);\n      });\n    }) : Promise.resolve(r);\n  }\n  isReady() {\n    var e, r;\n    return !((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && r.hasTag(\"loading\"));\n  }\n  get client() {\n    return this._client;\n  }\n}\nexport { Ee as AuthClient, yr as AuthClientSSR, qe as AuthCookieClient, b as CodifiedError, ve as EMAIL_NEEDS_VERIFICATION, Rr as HasuraAuthClient, $ as INITIAL_MACHINE_CONTEXT, R as INVALID_EMAIL_ERROR, ye as INVALID_MFA_CODE_ERROR, Ie as INVALID_MFA_TICKET_ERROR, ke as INVALID_MFA_TYPE_ERROR, Y as INVALID_PASSWORD_ERROR, Z as INVALID_PHONE_NUMBER_ERROR, Pe as INVALID_REFRESH_TOKEN, Oe as INVALID_SIGN_IN_METHOD, we as MIN_PASSWORD_LENGTH, ie as NETWORK_ERROR_CODE, O as NHOST_JWT_EXPIRES_AT_KEY, U as NHOST_REFRESH_TOKEN_ID_KEY, x as NHOST_REFRESH_TOKEN_KEY, Se as NO_MFA_TICKET_ERROR, Ae as NO_REFRESH_TOKEN, oe as OTHER_ERROR_CODE, X as REFRESH_TOKEN_MAX_ATTEMPTS, D as STATE_ERROR_CODE, Re as TOKEN_REFRESHER_RUNNING_ERROR, Q as TOKEN_REFRESH_MARGIN_SECONDS, k as USER_ALREADY_SIGNED_IN, wr as USER_NOT_ANONYMOUS, _e as USER_UNAUTHENTICATED, v as VALIDATION_ERROR_CODE, Sr as activateMfaPromise, ze as addSecurityKeyPromise, Qe as changeEmailPromise, Xe as changePasswordPromise, He as createAuthMachine, Ye as createChangeEmailMachine, je as createChangePasswordMachine, kr as createEnableMfaMachine, Fe as createResetPasswordMachine, Be as createSendVerificationEmailMachine, Ar as disableMfaPromise, sr as elevateEmailSecurityKeyPromise, F as encodeQueryParameters, Ir as generateQrCodePromise, A as getAuthenticationResult, $e as getFetch, K as getParameterByName, M as getSession, L as isBrowser, _ as isValidEmail, B as isValidPassword, ee as isValidPhoneNumber, We as isValidTicket, fr as linkIdTokenPromise, Le as localStorageGetter, Ge as localStorageSetter, I as postFetch, J as removeParameterFromWindow, Ze as resetPasswordPromise, S as rewriteRedirectTo, Je as sendVerificationEmailPromise, er as signInAnonymousPromise, ur as signInEmailOTPPromise, rr as signInEmailPasswordPromise, re as signInEmailPasswordlessPromise, nr as signInEmailSecurityKeyPromise, dr as signInIdTokenPromise, tr as signInMfaTotpPromise, ir as signInPATPromise, hr as signInSecurityKeyPromise, or as signInSmsPasswordlessOtpPromise, se as signInSmsPasswordlessPromise, ar as signOutPromise, te as signUpEmailPasswordPromise, cr as signUpEmailSecurityKeyPromise, lr as verifyEmailOTPPromise };","map":{"version":3,"names":["x","U","O","we","Q","X","ie","oe","v","D","b","Error","constructor","e","message","captureStackTrace","name","error","status","R","ke","ye","Y","Z","Ie","Se","Ae","Re","k","_e","wr","ve","Pe","Oe","$","user","mfa","accessToken","value","expiresAt","expiresInSeconds","refreshTimer","startedAt","attempts","lastAttempt","refreshToken","importTokenAttempts","errors","be","s","TextEncoder","encode","P","Uint8Array","r","t","String","fromCharCode","btoa","replace","q","length","n","padEnd","atob","i","ArrayBuffer","u","f","charCodeAt","ae","window","PublicKeyCredential","ce","id","transports","ue","test","p","code","cause","Ne","options","publicKey","signal","AbortSignal","authenticatorSelection","requireResidentKey","userVerification","pubKeyCredParams","filter","type","location","hostname","rp","byteLength","xe","createNewAbortSignal","controller","abort","AbortController","cancelCeremony","le","Ce","de","indexOf","fe","challenge","excludeCredentials","a","map","navigator","credentials","create","o","rawId","response","d","getTransports","h","getPublicKeyAlgorithm","W","E","getPublicKey","T","getAuthenticatorData","attestationObject","clientDataJSON","publicKeyAlgorithm","authenticatorData","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","console","warn","De","TextDecoder","decode","Ue","isConditionalMediationAvailable","Promise","Me","rpId","j","allowCredentials","document","querySelectorAll","mediation","get","userHandle","signature","G","V","Map","Ke","localStorage","getItem","Ve","defaultClientStorageSetter","setItem","removeItem","set","has","delete","Le","localStorageGetter","H","call","key","getItemAsync","Ge","localStorageSetter","expires","sameSite","httpOnly","remove","setItemAsync","deleteItemAsync","M","accessTokenExpiresIn","getTime","Date","now","A","getAuthenticationResult","isError","session","L","isBrowser","he","globalThis","fetch","EdgeRuntime","pe","me","fetchWrapper","token","body","extraHeaders","Accept","Authorization","method","headers","JSON","stringify","ok","json","reject","data","I","postFetch","$e","getFetch","F","encodeQueryParameters","Object","entries","Array","isArray","join","encodeURIComponent","S","rewriteRedirectTo","redirectTo","startsWith","URL","fromEntries","URLSearchParams","search","origin","pathname","slice","K","href","RegExp","exec","decodeURIComponent","J","hash","from","toString","history","pushState","_","toLowerCase","match","B","ee","We","He","createAuthMachine","backendUrl","clientUrl","broadcastKey","clientStorageType","clientStorage","refreshIntervalTime","autoRefreshToken","autoSignIn","postRequest","c","l","BroadcastChannel","N","schema","context","events","services","tsTypes","predictableActionArguments","states","authentication","initial","on","SESSION_UPDATE","cond","actions","target","starting","tags","always","invoke","src","onDone","onError","retryTokenImport","after","RETRY_IMPORT_TOKEN_DELAY","signedOut","entry","noErrors","success","needsSmsOtp","needsMfa","failed","signingOut","exit","SIGNIN_PASSWORD","SIGNIN_ANONYMOUS","SIGNIN_SECURITY_KEY_EMAIL","SIGNIN_SECURITY_KEY","SIGNIN_MFA_TOTP","SIGNIN_PAT","SIGNIN_ID_TOKEN","authenticating","password","pat","idToken","anonymous","totp","securityKeyEmail","securityKey","signedIn","SIGNOUT","disabled","stopped","idle","running","pending","internal","refreshing","TRY_TOKEN","registration","SIGNED_IN","incomplete","SIGNUP_EMAIL_PASSWORD","SIGNUP_SECURITY_KEY","PASSWORDLESS_EMAIL","PASSWORDLESS_SMS","PASSWORDLESS_SMS_OTP","SIGNIN_EMAIL_OTP","VERIFY_EMAIL_OTP","needsEmailVerification","needsOtp","emailPassword","passwordlessEmail","passwordlessSms","passwordlessSmsOtp","signInEmailOTP","verifyEmailOTP","complete","SIGNED_OUT","reportSignedIn","w","reportSignedOut","reportTokenChanged","incrementTokenImportAttempts","g","clearContext","clearContextExceptTokens","saveSession","m","toISOString","y","refreshTokenId","savePATSession","isPAT","saveMfaTicket","resetTimer","saveRefreshAttempt","saveAuthenticationError","resetErrors","saveRegistrationError","destroyRefreshToken","destroyAccessToken","cleanUrl","broadcastToken","postMessage","payload","guards","isAnonymous","isSignedIn","noToken","isRefreshTokenPAT","hasRefreshToken","isAutoRefreshDisabled","refreshTimerShouldRefresh","Math","pow","random","shouldRetryImportToken","unverified","hasSession","hasMfaTicket","isUnauthorizedError","signInPassword","email","signInPAT","personalAccessToken","signInIdToken","provider","nonce","phoneNumber","signInMethod","connection","otp","signInAnonymous","signInMfaTotp","ticket","signInSecurityKeyEmail","credential","signInSecurityKey","signout","all","signUpEmailPassword","requestOptions","signUpSecurityKey","nickname","z","ge","displayName","metadata","importRefreshToken","delays","Ye","createChangeEmailMachine","interpreter","REQUEST","requesting","saveInvalidEmailError","saveRequestError","reportError","reportSuccess","invalidEmail","requestChange","newEmail","getSnapshot","je","createChangePasswordMachine","saveInvalidPasswordError","invalidPassword","newPassword","kr","createEnableMfaMachine","imageUrl","secret","GENERATE","DISABLE","generating","generated","ACTIVATE","activating","activated","disabling","saveInvalidMfaTypeError","saveInvalidMfaCodeError","saveError","saveGeneration","totpSecret","reportGeneratedSuccess","reportGeneratedError","invalidMfaCode","invalidMfaType","activeMfaType","generate","activate","disable","Fe","createResetPasswordMachine","Be","createSendVerificationEmailMachine","request","Ee","start","devTools","_started","_subscriptionsQueue","Set","_subscriptions","_machine","_channel","addEventListener","send","initialSession","machine","withContext","_interpreter","C","initialized","stop","forEach","initialState","started","subscribe","add","log","qe","yr","ze","addSecurityKeyPromise","isSuccess","Qe","changeEmailPromise","onTransition","matches","Xe","changePasswordPromise","Ir","isGenerated","qrCodeDataUrl","Sr","activateMfaPromise","isActivated","Ar","disableMfaPromise","isDisabled","Ze","resetPasswordPromise","isSent","Je","sendVerificationEmailPromise","er","changed","rr","signInEmailPasswordPromise","needsMfaOtp","re","signInEmailPasswordlessPromise","nr","signInEmailSecurityKeyPromise","ne","sr","elevateEmailSecurityKeyPromise","elevated","tr","signInMfaTotpPromise","ir","signInPATPromise","se","signInSmsPasswordlessPromise","or","signInSmsPasswordlessOtpPromise","ar","signOutPromise","event","te","signUpEmailPasswordPromise","cr","signUpEmailSecurityKeyPromise","ur","signInEmailOTPPromise","lr","verifyEmailOTPPromise","dr","signInIdTokenPromise","fr","linkIdTokenPromise","hr","mr","createPATPromise","Rr","url","_client","signUp","waitUntilReady","connectProvider","connect","providerUrl","linkIdToken","signIn","signOut","resetPassword","changePassword","sendVerificationEmail","changeEmail","deanonymize","addSecurityKey","elevateEmailSecurityKey","createPAT","onTokenChanged","onAuthStateChanged","isAuthenticated","isAuthenticatedAsync","getAuthenticationStatus","client","isReady","isLoading","connectionAttempts","getAccessToken","getDecodedAccessToken","Te","getHasuraClaims","getHasuraClaim","refreshSession","getSession","initWithSession","getUser","hasTag","setTimeout","clearTimeout","resolve"],"sources":["D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\constants.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\errors.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\authentication\\context.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\node_modules\\.pnpm\\@simplewebauthn+browser@9.0.1\\node_modules\\@simplewebauthn\\browser\\dist\\bundle\\index.js","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\local-storage.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\client-helpers.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\environment.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\fetch.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\url.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\utils\\validators.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\authentication\\machine.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\change-email.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\change-password.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\enable-mfa.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\reset-password.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\machines\\send-verification-email.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\internal-client.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\addSecurityKey.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\changeEmail.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\changePassword.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\mfa.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\resetPassword.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\sendVerificationEmail.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInAnonymous.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInEmailPassword.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInEmailPasswordless.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInEmailSecurityKey.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\elevateEmailSecurityKey.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInMfaTotp.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInPAT.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInSmsPasswordless.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInSmsPasswordlessOtp.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signOut.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signUpEmailPassword.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signUpEmailSecurityKey.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInEmailOTP.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInIdToken.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\linkIdToken.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\signInSecurityKey.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\promises\\createPAT.ts","D:\\chatb\\chatbot-app\\frontend\\node_modules\\@nhost\\hasura-auth-js\\src\\hasura-auth-client.ts"],"sourcesContent":["export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_REFRESH_TOKEN_ID_KEY = 'nhostRefreshTokenId'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN_SECONDS = 60\n\nexport const REFRESH_TOKEN_MAX_ATTEMPTS = 5\n","import { AuthErrorPayload } from './types'\n\nexport const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: AuthErrorPayload\n  constructor(original: Error | AuthErrorPayload) {\n    super(original.message)\n\n    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor)\n\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationAuthErrorPayload = AuthErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN: AuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n\nexport const INVALID_SIGN_IN_METHOD: AuthErrorPayload = {\n  status: OTHER_ERROR_CODE,\n  error: 'invalid-sign-in-method',\n  message: 'Invalid sign-in method'\n}\n","import { AuthErrorPayload, User } from '../../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n    expiresInSeconds: number | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n    isPAT?: boolean\n  }\n  /** Number of times the user tried to get an access token from a refresh token but got a network error */\n  importTokenAttempts: number\n  errors: Partial<Record<StateErrorTypes, AuthErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null,\n    expiresInSeconds: 15\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  importTokenAttempts: 0,\n  errors: {}\n}\n","/* [@simplewebauthn/browser@9.0.1] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll('input[autocomplete$=\\'webauthn\\']');\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType, StorageGetter, StorageSetter } from './types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30, sameSite: 'lax', httpOnly: false })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n","import { AuthContext } from '../machines'\nimport { SessionActionHandlerResult } from '../promises'\nimport { NhostSession, SignUpResponse } from '../types'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (!context || !context.accessToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  refreshToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: refreshToken, user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n","export const isBrowser = () =>\n  typeof window !== 'undefined' && typeof window.location !== 'undefined'\n","import fetchPonyfill from 'fetch-ponyfill'\nimport { NETWORK_ERROR_CODE } from '../errors'\nimport { NullableErrorResponse } from '../types'\n\ndeclare const EdgeRuntime: any\n\ninterface FetchResponse<T> extends NullableErrorResponse {\n  data: T\n}\n\nlet fetch = globalThis.fetch\n\nif (typeof EdgeRuntime !== 'string') {\n  fetch = fetchPonyfill().fetch\n}\n\nconst fetchWrapper = async <T>(\n  url: string,\n  method: 'GET' | 'POST',\n  {\n    token,\n    body,\n    extraHeaders\n  }: { token?: string | null; body?: any; extraHeaders?: HeadersInit } = {}\n): Promise<FetchResponse<T>> => {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: '*/*'\n  }\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`\n  }\n\n  const mergedHeaders = { ...headers, ...extraHeaders }\n\n  const options: RequestInit = {\n    method,\n    headers: mergedHeaders\n  }\n  if (body) {\n    options.body = JSON.stringify(body)\n  }\n  try {\n    const result = await fetch(url, options)\n    if (!result.ok) {\n      const error = await result.json()\n      return Promise.reject<FetchResponse<T>>({ error })\n    }\n    try {\n      const data = await result.json()\n      return { data, error: null }\n    } catch {\n      console.warn(`Unexpected response: can't parse the response of the server at ${url}`)\n      return { data: 'OK' as any, error: null }\n    }\n  } catch (e) {\n    const error = {\n      message: 'Network Error',\n      status: NETWORK_ERROR_CODE,\n      error: 'network'\n    }\n    return Promise.reject<FetchResponse<T>>({ error })\n  }\n}\n\nexport const postFetch = async <T>(\n  url: string,\n  body: any,\n  token?: string | null,\n  extraHeaders?: HeadersInit\n): Promise<FetchResponse<T>> => fetchWrapper<T>(url, 'POST', { token, body, extraHeaders })\n\nexport const getFetch = <T>(url: string, token?: string | null): Promise<FetchResponse<T>> =>\n  fetchWrapper<T>(url, 'GET', { token })\n","import { RedirectOption } from '../types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n","import { MIN_PASSWORD_LENGTH } from '../constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n","import { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { assign, createMachine, InterpreterFrom, send } from 'xstate'\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_ID_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_MAX_ATTEMPTS,\n  TOKEN_REFRESH_MARGIN_SECONDS\n} from '../../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NETWORK_ERROR_CODE,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE\n} from '../../errors'\nimport { localStorageGetter, localStorageSetter } from '../../local-storage'\nimport {\n  AuthErrorPayload,\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInEmailOTPResponse,\n  SignInMfaTotpResponse,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse,\n  VerifyEmailOTPResponse\n} from '../../types'\nimport {\n  getParameterByName,\n  isValidEmail,\n  isValidPassword,\n  isValidPhoneNumber,\n  isValidTicket,\n  postFetch,\n  removeParameterFromWindow,\n  rewriteRedirectTo\n} from '../../utils'\nimport { AuthContext, INITIAL_MACHINE_CONTEXT } from './context'\nimport { AuthEvents } from './events'\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\nexport type AuthInterpreter = InterpreterFrom<AuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  signInEmailOTP: { data: SignInEmailOTPResponse }\n  verifyEmailOTP: { data: VerifyEmailOTPResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInPAT: { data: SignInPATResponse }\n  signInIdToken: { data: SignInResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  signInSecurityKey: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  broadcastKey,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = localStorageSetter(clientStorageType, clientStorage)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    token?: string | null,\n    headers?: Record<string, string>\n  ): Promise<T> => {\n    const result = await postFetch<T>(`${backendUrl}${url}`, data, token, headers)\n\n    return result.data\n  }\n\n  // Create a shared BroadcastChannel for broadcasting tokens and signout events\n  let sharedBroadcastChannel: BroadcastChannel | null = null\n  if (typeof window !== 'undefined' && broadcastKey) {\n    try {\n      sharedBroadcastChannel = new BroadcastChannel(broadcastKey)\n      // console.debug('[AUTH] Created shared BroadcastChannel with key:', broadcastKey)\n    } catch (error) {\n      // console.debug('[AUTH] BroadcastChannel is not available e.g. react-native')\n    }\n  }\n\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./machine.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      predictableActionArguments: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: 'signedIn'\n                  },\n                  {\n                    target: 'signedOut'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'shouldRetryImportToken',\n                    actions: 'incrementTokenImportAttempts',\n                    target: 'retryTokenImport'\n                  },\n                  { actions: ['saveAuthenticationError'], target: 'signedOut' }\n                ]\n              }\n            },\n            retryTokenImport: {\n              tags: ['loading'],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: 'starting'\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptTokens'],\n                  exit: ['destroyAccessToken', 'destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_SECURITY_KEY: 'authenticating.securityKey',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp',\n                SIGNIN_PAT: 'authenticating.pat',\n                SIGNIN_ID_TOKEN: 'authenticating.idToken'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                pat: {\n                  invoke: {\n                    src: 'signInPAT',\n                    id: 'authenticateWithPAT',\n                    onDone: {\n                      actions: ['savePATSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                idToken: {\n                  invoke: {\n                    src: 'signInIdToken',\n                    id: 'authenticateWithIdToken',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                securityKey: {\n                  invoke: {\n                    src: 'signInSecurityKey',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        { cond: 'isRefreshTokenPAT', target: 'disabled' },\n                        { cond: 'hasRefreshToken', target: 'running' }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: [\n                                'saveSession',\n                                'resetTimer',\n                                'reportTokenChanged',\n                                'broadcastToken'\n                              ],\n                              target: 'pending'\n                            },\n                            onError: [\n                              {\n                                cond: 'isUnauthorizedError',\n                                target: '#nhost.authentication.signedOut'\n                              },\n                              { actions: 'saveRefreshAttempt', target: 'pending' }\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged', 'broadcastToken'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp',\n                SIGNIN_EMAIL_OTP: 'signInEmailOTP',\n                VERIFY_EMAIL_OTP: 'verifyEmailOTP'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            signInEmailOTP: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signInEmailOTP',\n                id: 'signInEmailOTP',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            verifyEmailOTP: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'verifyEmailOTP',\n                id: 'verifyEmailOTP',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        incrementTokenImportAttempts: assign({\n          importTokenAttempts: ({ importTokenAttempts }) => importTokenAttempts + 1\n        }),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptTokens: assign(({ accessToken, refreshToken }) => {\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            accessToken: accessToken,\n            refreshToken: refreshToken\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken }\n          }\n        }),\n\n        savePATSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken, isPAT: true }\n          }\n        }),\n\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({}),\n          importTokenAttempts: (_) => 0\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        destroyAccessToken: assign({\n          accessToken: (_) => {\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the session to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn && broadcastKey && sharedBroadcastChannel) {\n            try {\n              // console.debug('[AUTH] Broadcasting new token to other tabs:', context.refreshToken.value ? context.refreshToken.value.substring(0, 6) + '...' : 'null')\n              sharedBroadcastChannel.postMessage({\n                type: 'broadcast_session',\n                payload: {\n                  token: context.refreshToken.value,\n                  accessToken: context.accessToken.value,\n                  user: context.user,\n                  expiresAt: context.accessToken.expiresAt\n                    ? context.accessToken.expiresAt.toISOString()\n                    : null,\n                  expiresInSeconds: context.accessToken.expiresInSeconds\n                }\n              })\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        isRefreshTokenPAT: (ctx) => !!ctx.refreshToken?.isPAT,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n\n          if (!expiresAt) {\n            return false\n          }\n\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If the refresh timer reached the maximum number of attempts, we should not try again\n            if (ctx.refreshTimer.attempts > REFRESH_TOKEN_MAX_ATTEMPTS) {\n              return false\n            }\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            // * Exponential backoff\n            return elapsed > Math.pow(2, ctx.refreshTimer.attempts - 1) * 5_000\n          }\n\n          // This happens when either the computer goes to sleep or when Chrome decides to suspend the tab\n          if (expiresAt.getTime() < Date.now()) {\n            return true\n          }\n\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refreshed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN_SECONDS seconds before the JWT expires\n          const accessTokenExpirationTime = ctx.accessToken.expiresInSeconds\n\n          if (!accessTokenExpirationTime) {\n            return false\n          }\n\n          const expiresInMilliseconds = expiresAt.getTime() - Date.now()\n\n          return (\n            expiresInMilliseconds <= (TOKEN_REFRESH_MARGIN_SECONDS * 1000) / 2 ||\n            (expiresInMilliseconds <= TOKEN_REFRESH_MARGIN_SECONDS * 1000 && Math.random() < 0.1)\n          )\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Should retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (ctx, e: any) =>\n          ctx.importTokenAttempts < REFRESH_TOKEN_MAX_ATTEMPTS &&\n          (e.data.error.status === NETWORK_ERROR_CODE || e.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa,\n        isUnauthorizedError: (_, { data: { error } }: any) => error.status === 401\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        signInPAT: (_context, { pat }) => {\n          return postRequest<SignInPATResponse>('/signin/pat', {\n            personalAccessToken: pat\n          })\n        },\n        signInIdToken: (_context, { provider, idToken, nonce }) => {\n          return postRequest<SignInResponse>('/signin/idtoken', {\n            provider,\n            idToken,\n            ...(nonce && { nonce })\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        signInEmailOTP: (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n\n          return postRequest('/signin/otp/email', {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n        },\n        verifyEmailOTP: (_, { email, otp }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n\n          return postRequest('/signin/otp/email/verify', {\n            email,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          // console.debug('[AUTH] Refreshing token with:', refreshToken ? refreshToken.substring(0, 6) + '...' : 'null')\n          const session: NhostSession = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          // console.debug('[AUTH] Token refreshed successfully:', session.refreshToken ? session.refreshToken.substring(0, 6) + '...' : 'null')\n          return { session, error: null }\n        },\n        signInSecurityKey: async (): Promise<SignInResponse> => {\n          try {\n            const options: PublicKeyCredentialRequestOptionsJSON = await postRequest(\n              '/signin/webauthn',\n              {}\n            )\n\n            let credential: AuthenticationCredentialJSON\n            try {\n              credential = await startAuthentication(options)\n            } catch (e) {\n              throw new CodifiedError(e as Error)\n            }\n            return postRequest<SignInResponse>('/signin/webauthn/verify', { credential })\n          } catch (error) {\n            throw new CodifiedError(error as Error)\n          }\n        },\n        signout: async (ctx, e) => {\n          const signOutResponse = await postRequest(\n            '/signout',\n            {\n              refreshToken: ctx.refreshToken.value,\n              all: !!e.all\n            },\n            !!e.all ? ctx.accessToken.value : undefined\n          )\n\n          if (broadcastKey && sharedBroadcastChannel) {\n            try {\n              // ? broadcast the signout event to other tabs to remove the accessToken\n              sharedBroadcastChannel.postMessage({ type: 'signout' })\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n\n          return signOutResponse\n        },\n        signUpEmailPassword: async (context, { email, password, options, requestOptions }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value,\n              requestOptions?.headers\n            )\n          } else {\n            return postRequest<SignUpResponse>(\n              '/signup/email-password',\n              {\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              null,\n              requestOptions?.headers\n            )\n          }\n        },\n        signUpSecurityKey: async (_, { email, options, requestOptions }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options },\n            null,\n            requestOptions?.headers\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname,\n              displayName: options?.displayName,\n              ...(options?.metadata && { metadata: options?.metadata })\n            }\n          })\n        },\n        importRefreshToken: async (ctx) => {\n          if (\n            ctx.user &&\n            ctx.refreshToken.value &&\n            ctx.accessToken.value &&\n            ctx.accessToken.expiresAt\n          ) {\n            // * Do not import refresh token if the session already exists (loaded through initial state)\n            // TODO this should eventually be handled upstream in the state machine\n            return {\n              session: {\n                accessToken: ctx.accessToken.value,\n                accessTokenExpiresIn: ctx.accessToken.expiresAt.getTime() - Date.now(),\n                refreshToken: ctx.refreshToken.value,\n                user: ctx.user\n              },\n              error: null\n            }\n          }\n          let error: AuthErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: AuthErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              const errorDescription = getParameterByName('errorDescription')\n\n              if (error) {\n                if (errorDescription !== 'social user already exists') {\n                  return Promise.reject<NhostSessionResponse>({\n                    session: null,\n                    error: {\n                      status: VALIDATION_ERROR_CODE,\n                      error,\n                      message: errorDescription || error\n                    }\n                  })\n                }\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: AuthErrorPayload }).error\n            }\n          }\n          if (error) {\n            return Promise.reject<NhostSessionResponse>({ error, session: null })\n          }\n          return { error: null, session: null }\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts }) => {\n          // * Exponential backoff\n          return Math.pow(2, importTokenAttempts - 1) * 5_000\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ChangeEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await postFetch(\n            `${backendUrl}/user/email/change`,\n            { newEmail: email, options: rewriteRedirectTo(clientUrl, options) },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_PASSWORD_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangePasswordResponse } from '../types'\nimport { postFetch } from '../utils'\nimport { isValidPassword } from '../utils/validators'\n\nexport type ChangePasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          postFetch<ChangePasswordResponse>(\n            `${backendUrl}/user/password`,\n            { newPassword: password, ticket: ticket },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload } from '../types'\nimport { getFetch, postFetch } from '../utils'\n\nexport type EnableMfaContext = {\n  error: AuthErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'DISABLE'; code: string }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: AuthErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating',\n            DISABLE: 'disabling'\n          },\n          states: {\n            initial: {},\n            error: {},\n            disabled: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ],\n                DISABLE: '#enableMfa.disabling'\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        },\n        disabling: {\n          invoke: {\n            src: 'disable',\n            id: 'disable',\n            onDone: { target: 'idle.disabled', actions: 'reportSuccess' },\n            onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx, event) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await getFetch(\n            `${backendUrl}/mfa/totp/generate`,\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType },\n            interpreter?.getSnapshot().context.accessToken.value\n          ),\n        disable: (_, { code }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType: '' },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ResetPasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          postFetch<ResetPasswordResponse>(`${backendUrl}/user/password/reset`, {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n","import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport {\n  AuthErrorPayload,\n  SendVerificationEmailOptions,\n  SendVerificationEmailResponse\n} from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type SendVerificationEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await postFetch<SendVerificationEmailResponse>(\n            `${backendUrl}/user/email/send-verification-email`,\n            { email, options: rewriteRedirectTo(clientUrl, options) }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n","import { interpret } from 'xstate'\nimport {\n  AuthContext,\n  AuthInterpreter,\n  AuthMachine,\n  AuthMachineOptions,\n  createAuthMachine\n} from './machines'\nimport { NhostSession } from './types'\nimport { isBrowser } from './utils'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  private _machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _started = false\n  private _channel?: BroadcastChannel\n  private _subscriptionsQueue: Set<(client: AuthClient) => void> = new Set()\n  private _subscriptions: Set<() => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    broadcastKey,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this._machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      broadcastKey,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.start({ devTools })\n    }\n\n    if (typeof window !== 'undefined' && broadcastKey) {\n      try {\n        this._channel = new BroadcastChannel(broadcastKey)\n\n        if (autoSignIn) {\n          this._channel?.addEventListener('message', (event) => {\n            const { type, payload } = event.data\n\n            if (type === 'broadcast_session') {\n              const context = this.interpreter?.getSnapshot().context\n              const existingToken = context?.refreshToken.value\n\n              // console.debug('[AUTH] Received broadcast session:', payload.token?.substring(0,6), existingToken?.substring(0,6))\n\n              // Only update if this is a new token or if we don't have a token yet\n              if (this.interpreter && payload.token && payload.token !== existingToken) {\n                // console.debug('[AUTH] Received broadcast with new token:', payload.token ? payload.token.substring(0, 6) + '...' : 'null',\n                //   'Previous token:', existingToken ? existingToken.substring(0, 6) + '...' : 'null')\n                // Send a SESSION_UPDATE event with the full session data instead of making a token call\n                this.interpreter.send('SESSION_UPDATE', {\n                  data: {\n                    session: {\n                      user: payload.user,\n                      accessToken: payload.accessToken,\n                      refreshToken: payload.token,\n                      accessTokenExpiresIn: payload.expiresInSeconds\n                    }\n                  }\n                })\n              }\n            }\n          })\n        }\n\n        this._channel.addEventListener('message', (event) => {\n          const { type } = event.data\n\n          if (type === 'signout') {\n            if (this.interpreter) {\n              this.interpreter.send('SIGNOUT')\n            }\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  start({\n    devTools = false,\n    initialSession,\n    interpreter\n  }: { interpreter?: AuthInterpreter; initialSession?: NhostSession; devTools?: boolean } = {}) {\n    // Create a deep copy of the machine context to ensure that nested objects (such as accessToken and refreshToken) are not mutated in the original context.\n    const context: AuthContext = {\n      ...this.machine.context,\n      accessToken: {\n        ...this.machine.context.accessToken\n      },\n      refreshToken: {\n        ...this.machine.context.refreshToken\n      }\n    }\n\n    if (initialSession) {\n      context.user = initialSession.user\n      context.refreshToken.value = initialSession.refreshToken ?? null\n      context.accessToken.value = initialSession.accessToken ?? null\n      context.accessToken.expiresAt = new Date(\n        Date.now() + initialSession.accessTokenExpiresIn * 1_000\n      )\n    }\n    const machineWithInitialContext = this.machine.withContext(context)\n\n    if (!this._interpreter) {\n      this._interpreter = interpreter || interpret(machineWithInitialContext, { devTools })\n    }\n\n    // * Start the interpreter if not started already. Always restart the interpreter when on the server side\n    if (!this._started || typeof window === 'undefined') {\n      if (this._interpreter.initialized) {\n        this._interpreter.stop()\n        this._subscriptions.forEach((fn) => fn())\n      }\n      this._interpreter.start(machineWithInitialContext.initialState)\n      this._subscriptionsQueue.forEach((fn) => fn(this))\n    }\n\n    this._started = true\n  }\n\n  public get machine() {\n    return this._machine\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n\n  get started(): boolean {\n    return this._started\n  }\n\n  subscribe(fn: (client: AuthClient) => () => void): () => void {\n    if (this.started) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      const subscription = fn(this)\n      this._subscriptions.add(subscription)\n      return subscription\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptionsQueue.add(fn)\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n}\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser() && options.autoSignIn,\n      autoRefreshToken: isBrowser() && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n","import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { postFetch } from '..'\nimport { CodifiedError } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, SecurityKey } from '../types'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface AddSecurityKeyHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, AuthActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  try {\n    const { data: options } = await postFetch<PublicKeyCredentialCreationOptionsJSON>(\n      `${backendUrl}/user/webauthn/add`,\n      {},\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await postFetch<SecurityKey>(\n      `${backendUrl}/user/webauthn/verify`,\n      { credential, nickname },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult\n  extends AuthActionErrorState,\n    NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, AuthActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, AuthActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password,\n      ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { AuthActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends AuthActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n  totpSecret: string | null\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\n\nexport interface ActivateMfaHandlerResult extends AuthActionErrorState {\n  isActivated: boolean\n}\n\nexport interface DisableMfaHandlerResult extends AuthActionErrorState {\n  isDisabled: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || '',\n          totpSecret: state.context.secret\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: '',\n          totpSecret: state.context.secret\n        })\n      }\n    })\n  })\n\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n\nexport const disableMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<DisableMfaHandlerResult>((resolve) => {\n    service.send('DISABLE', { code })\n    service.onTransition((state) => {\n      if (state.matches({ idle: 'disabled' })) {\n        resolve({ error: null, isDisabled: true, isError: false })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isDisabled: false, isError: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, AuthActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends AuthActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState\n  extends SignInAnonymousHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { PublicKeyCredentialRequestOptionsJSON } from '@simplewebauthn/typescript-types'\nimport {\n  AuthActionErrorState,\n  AuthActionSuccessState,\n  AuthClient,\n  AuthErrorPayload,\n  postFetch,\n  SignInResponse\n} from '..'\nimport { startAuthentication } from '@simplewebauthn/browser'\n\nexport interface ElevateWithSecurityKeyHandlerResult\n  extends AuthActionSuccessState,\n    AuthActionErrorState {\n  elevated: boolean\n}\n\nfunction createAuthErrorPayload(e: any) {\n  const error: AuthErrorPayload = {\n    error: e.message || 'Something went wrong!',\n    status: e.status || 1,\n    message: e.message || 'Something went wrong!'\n  }\n\n  return error\n}\n\nexport const elevateEmailSecurityKeyPromise = async (authClient: AuthClient, email: string) => {\n  const snapshot = authClient.interpreter?.getSnapshot()\n  const accessToken = snapshot?.context.accessToken.value\n\n  let data: PublicKeyCredentialRequestOptionsJSON\n  try {\n    const response = await postFetch<PublicKeyCredentialRequestOptionsJSON>(\n      `${authClient.backendUrl}/elevate/webauthn`,\n      {\n        email\n      },\n      accessToken\n    )\n    data = response.data\n  } catch (e: any) {\n    const error = createAuthErrorPayload(e)\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n\n  let credential\n  try {\n    credential = await startAuthentication(data)\n  } catch (e: any) {\n    const error = createAuthErrorPayload(e)\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n\n  try {\n    const {\n      data: { session },\n      error: signInError\n    } = await postFetch<SignInResponse>(\n      `${authClient.backendUrl}/elevate/webauthn/verify`,\n      {\n        email,\n        credential\n      },\n      accessToken\n    )\n\n    if (session && !signInError) {\n      authClient.interpreter?.send({\n        type: 'SESSION_UPDATE',\n        data: {\n          session\n        }\n      })\n\n      return {\n        error: null,\n        isError: false,\n        isSuccess: true,\n        elevated: true\n      }\n    }\n\n    return {\n      error: signInError!,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n\n    return {\n      error,\n      isError: true,\n      isSuccess: false,\n      elevated: false\n    }\n  }\n}\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, AuthActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInPATHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInPATState extends SignInPATHandlerResult, AuthActionLoadingState {}\n\nexport const signInPATPromise = (\n  interpreter: AuthInterpreter,\n  pat: string\n): Promise<SignInPATHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_PAT', { pat })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, AuthActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { RequestOptions, SignUpOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions,\n  requestOptions?: RequestOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options,\n      requestOptions\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { RequestOptions, SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions,\n  requestOptions?: RequestOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options,\n      requestOptions\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { EmailOTPOptions } from '../types'\n\nimport {\n  AuthActionErrorState,\n  AuthActionLoadingState,\n  AuthActionSuccessState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailOTPHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent via email, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport interface SignInEmailOTPState extends SignInEmailOTPHandlerResult, AuthActionLoadingState {}\n\nexport interface VerifyEmailOTPHandlerResult extends SessionActionHandlerResult {}\n\nexport const signInEmailOTPPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: EmailOTPOptions\n) =>\n  new Promise<SignInEmailOTPHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_EMAIL_OTP', { email, options })\n\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n\nexport const verifyEmailOTPPromise = (interpreter: AuthInterpreter, email: string, otp: string) =>\n  new Promise<VerifyEmailOTPHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'VERIFY_EMAIL_OTP', email, otp })\n\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { Provider } from '../types'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInIdTokenHandlerParams {\n  provider: Provider\n  idToken: string\n  nonce?: string\n}\n\nexport interface SignInIdTokenHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInIdTokenState extends SignInIdTokenHandlerResult, AuthActionLoadingState {}\n\nexport const signInIdTokenPromise = (\n  interpreter: AuthInterpreter,\n  { provider, idToken, nonce }: SignInIdTokenHandlerParams\n): Promise<SignInIdTokenHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ID_TOKEN', {\n      provider,\n      idToken,\n      ...(nonce && { nonce })\n    })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n","import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, Provider } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionSuccessState } from './types'\n\nexport interface LinkIdTokenHandlerParams {\n  provider: Provider\n  idToken: string\n  nonce?: string\n}\n\nexport interface LinkIdTokenHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const linkIdTokenPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { provider, idToken, nonce }: LinkIdTokenHandlerParams\n): Promise<LinkIdTokenHandlerResult> => {\n  try {\n    await postFetch<string>(\n      `${backendUrl}/link/idtoken`,\n      { provider, idToken, ...(nonce && { nonce }) },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n","import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyState\n  extends SignInSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSecurityKeyPromise = (interpreter: AuthInterpreter) =>\n  new Promise<SignInSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY' })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n","import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, PersonalAccessTokenCreationResponse } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface CreatePATHandlerParams {\n  /**\n   * The expiration date of the personal access token.\n   */\n  expiresAt: Date\n  /**\n   * Optional metadata to attach to the personal access token.\n   */\n  metadata?: Record<string, string | number>\n}\n\nexport interface CreatePATHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * The data returned by the backend.\n   */\n  data?: {\n    /**\n     * The ID of the personal access token that was created.\n     */\n    id?: string | null\n    /**\n     * The personal access token that was created.\n     */\n    personalAccessToken?: string | null\n  } | null\n}\n\nexport interface CreatePATState extends CreatePATHandlerResult, AuthActionLoadingState {}\n\nexport const createPATPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { expiresAt, metadata }: CreatePATHandlerParams\n): Promise<CreatePATHandlerResult> => {\n  try {\n    const { data } = await postFetch<PersonalAccessTokenCreationResponse>(\n      `${backendUrl}/pat`,\n      { expiresAt: expiresAt.toISOString(), metadata },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      data: data\n        ? {\n            id: data.id || null,\n            personalAccessToken: data.personalAccessToken || null\n          }\n        : null,\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false, data: null }\n  }\n}\n","import { jwtDecode } from 'jwt-decode'\nimport { interpret } from 'xstate'\nimport {\n  EMAIL_NEEDS_VERIFICATION,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  NO_REFRESH_TOKEN,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from './errors'\nimport { AuthClient } from './internal-client'\nimport {\n  AuthInterpreter,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine\n} from './machines'\nimport {\n  addSecurityKeyPromise,\n  changeEmailPromise,\n  changePasswordPromise,\n  elevateEmailSecurityKeyPromise,\n  resetPasswordPromise,\n  sendVerificationEmailPromise,\n  signInAnonymousPromise,\n  signInEmailOTPPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailPasswordPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  signInPATPromise,\n  signInSecurityKeyPromise,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise,\n  verifyEmailOTPPromise\n} from './promises'\nimport { createPATPromise } from './promises/createPAT'\nimport { linkIdTokenPromise } from './promises/linkIdToken'\nimport { signInIdTokenPromise } from './promises/signInIdToken'\nimport {\n  AuthChangedFunction,\n  AuthErrorPayload,\n  ChangeEmailParams,\n  ChangeEmailResponse,\n  ChangePasswordParams,\n  ChangePasswordResponse,\n  ConnectProviderParams,\n  ConnectProviderResponse,\n  DeanonymizeParams,\n  DeanonymizeResponse,\n  EmailOTPOptions,\n  JWTClaims,\n  JWTHasuraClaims,\n  LinkIdTokenParams,\n  NhostAuthConstructorParams,\n  NhostSession,\n  NhostSessionResponse,\n  OnTokenChangedFunction,\n  RequestOptions,\n  ResetPasswordParams,\n  ResetPasswordResponse,\n  SecurityKey,\n  SendVerificationEmailParams,\n  SendVerificationEmailResponse,\n  SignInIdTokenParams,\n  SignInParams,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpParams,\n  SignUpResponse\n} from './types'\nimport {\n  encodeQueryParameters,\n  getAuthenticationResult,\n  getSession,\n  isBrowser,\n  rewriteRedirectTo\n} from './utils'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    broadcastKey,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    clientStorage,\n    clientStorageType,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      broadcastKey,\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams, requestOptions?: RequestOptions): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    if ('securityKey' in params) {\n      const { email, options } = params\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options, requestOptions)\n      )\n    }\n    const { email, password, options } = params\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, password, options, requestOptions)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.connectProvider` to connect a social authentication provider to an existing user account\n   *\n   * @example\n   * ### Connect an authentication provider to an existing user account\n   * ```ts\n   * nhost.auth.connectProvider({\n   *   provider: 'github\n   *   options: {\n   *    redirectTo: window.location.href\n   *   }\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/connect-provider\n   */\n  async connectProvider(params: ConnectProviderParams): Promise<ConnectProviderResponse> {\n    const interpreter = await this.waitUntilReady()\n    const accessToken = interpreter.getSnapshot().context.accessToken.value\n\n    const { provider, options } = params\n\n    const providerUrl = encodeQueryParameters(\n      `${this._client.backendUrl}/signin/provider/${provider}`,\n      rewriteRedirectTo(this._client.clientUrl, {\n        ...options,\n        connect: accessToken\n      } as any)\n    )\n    if (isBrowser()) {\n      window.location.href = providerUrl\n    }\n\n    return { providerUrl }\n  }\n\n  /**\n   * Use `nhost.auth.signInIdToken` to sign in a user with the provider's account using an ID token\n   *\n   * @example\n   * ### Sign in a user with an id token\n   * ```ts\n   * nhost.auth.signInIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-idtoken\n   */\n  async signInIdToken(params: SignInIdTokenParams) {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await signInIdTokenPromise(interpreter, params)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.linkIdToken` to link a user account with the provider's account using an ID token\n   *\n   * @example\n   * ### Link a user account with the provider's account using an id token\n   * ```ts\n   * nhost.auth.linkIdToken({\n   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.\n   *   idToken: '...', // The ID token issued by the provider.\n   *   nonce: '...', // Optional: The nonce used during token generation.\n   * })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/link-idtoken\n   */\n  async linkIdToken(params: LinkIdTokenParams) {\n    return linkIdTokenPromise(this._client, params)\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat\n   *\n   * @param personalAccessToken - The personal access token to sign in with\n   */\n  async signInPAT(personalAccessToken: string): Promise<SignInPATResponse> {\n    const interpreter = await this.waitUntilReady()\n    const res = await signInPATPromise(interpreter, personalAccessToken)\n\n    return getAuthenticationResult(res)\n  }\n\n  /**\n   * Use `nhost.auth.signInEmailOTP` to sign in with an email one-time password (OTP).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInEmailOTP('user@example.com')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-email-otp\n   *\n   * @param email - The email address to send the OTP to\n   */\n  async signInEmailOTP(email: string, options?: EmailOTPOptions): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const { error } = await signInEmailOTPPromise(interpreter, email, options)\n\n    return {\n      error,\n      session: null,\n      mfa: null\n    }\n  }\n\n  /**\n   * Use `nhost.auth.verifyEmailOTP` to verify an email one-time password (OTP) and complete the sign-in process\n   *\n   * @example\n   * ```ts\n   * nhost.auth.verifyEmailOTP('user@example.com', '123456')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/verify-email-otp\n   *\n   * @param email - The email address to verify the OTP for\n   * @param otp - The one-time password sent to the email address\n   */\n  async verifyEmailOTP(email: string, otp: string): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await verifyEmailOTPPromise(interpreter, email, otp)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInSecurityKey` to sign in a user with a security key using the WebAuthn API\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInSecurityKey()\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-security-key\n   */\n  async signInSecurityKey(): Promise<SignInResponse> {\n    const interpreter = await this.waitUntilReady()\n\n    const res = await signInSecurityKeyPromise(interpreter)\n\n    return { ...getAuthenticationResult(res), mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey` to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: AuthErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.elevateEmailSecurityKey` to get a temporary elevated auth permissions to run sensitive operations.\n   * @param email user email\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/elevate-email-security-key\n   */\n  async elevateEmailSecurityKey(email: string) {\n    if (!email) {\n      throw Error('A user email is required')\n    }\n\n    const res = await elevateEmailSecurityKeyPromise(this._client, email)\n\n    return { ...res, mfa: null }\n  }\n\n  /**\n   * Use `nhost.auth.createPAT` to create a personal access token for the user.\n   *\n   * @param expiresAt Expiration date for the token\n   * @param metadata Optional metadata to store with the token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat\n   */\n  async createPAT(expiresAt: Date, metadata?: Record<string, string | number>) {\n    return createPATPromise(this._client, { expiresAt, metadata })\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwtDecode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHasuraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshSession();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshSession(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   * Initialize the auth client with an existing session\n   *\n   * @example\n   * ### Initialize with an existing Nhost session\n   * ```ts\n   * await nhost.auth.initWithSession({ session: initialSession })\n   * ```\n   *\n   * @param session - The Nhost session object to initialize the client with\n   * @docs https://docs.nhost.io/reference/javascript/auth/init-with-session\n   */\n  async initWithSession({ session }: { session: NhostSession }): Promise<void> {\n    this.client.start({ initialSession: session })\n    await this.waitUntilReady()\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}